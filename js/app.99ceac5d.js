(()=>{var e={93450:(e,n,t)=>{"use strict";var o=t(61957),r=t(71947),s=t(60499),i=t(59835),a=t(86970);function l(e,n,t,o,r,s){const l=(0,i.up)("router-view");return(0,i.wg)(),(0,i.j4)(l,{class:(0,a.C_)(`free-app free-theme-${e.store.theme||"default"}`)},null,8,["class"])}var d=t(36278);const u=(0,i.aZ)({name:"App",setup(){const e=(0,d.Z)();return{store:e}}});var c=t(11639);const m=(0,c.Z)(u,[["render",l]]),h=m;var f=t(23340),p=t(3746);const g=(0,f.h)((function(){const e=(0,p.WB)();return console.log("createPinia"),e}));var y=t(28339);const b=(0,f.BC)((async function(){const e=y.r5,n=(0,y.p7)({scrollBehavior:async(e,n,t)=>new Promise((e=>t?setTimeout((()=>e(t)),500):{x:0,y:0})),routes:[],history:e("")});return n}));async function v(e,n){const t=e(h);t.use(r.Z,n);const o="function"===typeof g?await g({}):g;t.use(o);const i=(0,s.Xl)("function"===typeof b?await b({store:o}):b);return o.use((({store:e})=>{e.router=i})),{app:t,store:o,router:i}}var w=t(99527),x=t(85448),j=t(6827),S=t(11530),E=t(86229),I=t(26950),k=t(9114);const F={config:{screen:{bodyClasses:!0}},lang:w.Z,iconSet:x.Z,plugins:{Notify:j.Z,Dialog:S.Z,Meta:E.ZP,Loading:I.Z,Dark:k.Z}},T="";async function q({app:e,router:n,store:t},o){let r=!1;const s=e=>{try{return n.resolve(e).href}catch(t){}return Object(e)===e?null:e},i=e=>{if(r=!0,"string"===typeof e&&/^https?:\/\//.test(e))return void(window.location.href=e);const n=s(e);null!==n&&(window.location.href=n,window.location.reload())},a=window.location.href.replace(window.location.origin,"");for(let d=0;!1===r&&d<o.length;d++)try{await o[d]({app:e,router:n,store:t,ssrContext:null,redirect:i,urlPath:a,publicPath:T})}catch(l){return l&&l.url?void i(l.url):void console.error("[Quasar] boot error:",l)}!0!==r&&(e.use(n),e.mount("#q-app"))}v(o.ri,F).then((e=>{const[n,o]=void 0!==Promise.allSettled?["allSettled",e=>e.map((e=>{if("rejected"!==e.status)return e.value.default;console.error("[Quasar] boot error:",e.reason)}))]:["all",e=>e.map((e=>e.default))];return Promise[n]([Promise.resolve().then(t.bind(t,91569)),Promise.resolve().then(t.bind(t,11362)),Promise.resolve().then(t.bind(t,60991)),Promise.resolve().then(t.bind(t,24987))]).then((n=>{const t=o(n).filter((e=>"function"===typeof e));q(e,t)}))}))},91569:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>f,requests:()=>l});t(6822),t(69665);var o=t(23340),r=t(37524),s=t(37395),i=t(6827),a=t(36278);let l;const d=[],{baseUrl:u}=s.Z;r.Z.defaults.timeout=3e6;const c=r.Z.create({baseURL:u,timeout:3e6});c.interceptors.request.use((e=>(e.cancelToken=new r.Z.CancelToken((n=>{e.cancelTokenFunc=n})),e))),c.interceptors.response.use((e=>{if(e.config&&e.config.shouldCancelRequest&&("function"!==typeof e.config.shouldCancelRequest||e.config.shouldCancelRequest()))throw e.config.cancelTokenFunc(),new Error("request canceled");return e.data}),(e=>{e&&e.response&&401===e.response.status?"/login"!==window.location.pathname&&(window.location.pathname="/login"):e&&e.response&&404!==e.response.status&&e.response.data&&e.response.data.msg&&i.Z.create(e.response.data.msg||e.response.data.msg.message)}));const m=(e,n)=>{const t=d.find((t=>t.method===n&&new RegExp(t.url).test(e)));if(t&&t.func)return new Promise((e=>{e("function"===typeof t.func?t.func():t.func)}))},h=(e,n="")=>{let t=[];if("object"===typeof e)for(let o=0;o<Object.keys(e).length;o+=1){const r=Object.keys(e)[o],s=h(e[r],n?`${n}_DOT_${r}`:r);t=t.concat(s)}else n&&void 0!==e&&null!==e&&t.push(`${encodeURI(n)}=${encodeURI(e)}`);return t},f=(0,o.xr)((({app:e})=>{const n=(e,n,t=!1)=>{let o="";const r={shouldCancelRequest:n&&n.cancel_request};return n&&delete n.cancel_request,n&&Object.keys(n).length&&(e.indexOf("?")>0?o+="&":o+="?",o+=h(n).join("&")||""),t?window.open(`${s.Z.baseUrl}/${encodeURI(e)}${o}`):m(`${e}${o}`,"get")||c.get(encodeURI(e)+o,r)},t=(e,n)=>m(e,"post",n)||c.post(e,Object.decycle(n)),o=(e,n)=>m(e,"put",n)||c.put(e,Object.decycle(n)),r=(e,n)=>m(e,"delete",{data:n})||c.delete(e,{data:Object.decycle(n)});l={$axios:c,postRequest:t,getRequest:n,putRequest:o,deleteRequest:r,nothingRequest:()=>c.get("/nothing"),Mock:{mock:(e,n="get",t)=>{d.push({url:e,method:n,func:t})}},canI:async e=>{const n=(0,a.Z)();if(n&&n.canI){const t=n.canI.find((n=>n&&n.url===e));if(t&&"undefined"!==typeof t.can)return new Promise((e=>{e(!!t.can)}))}try{const o=await t("can_i",{url:e});let r=o&&o.data&&o.data.can;const s=e.split(",");r=Array.isArray(r)?r:[r];for(let e=0;e<s.length;e+=1){const t=s[e];n.ADD_CANI({url:t,can:r[e]||!1})}return 1===r.length?r[0]:r}catch(o){return!1}}},Object.assign(e.config.globalProperties,l)}))},11362:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>l});t(69665);var o=t(23340),r=t(21463),s=t(37395),i=t(60991);const a={"en-us":{error404:"Sorry, nothing here...",goback:"Go Back",LOGIN:"Login",LOGOUT:"Logout",REGISTER:"Register",SETTINGS:"Settings"},"zh-cn":{error404:"抱歉，此页面不存在...",goback:"返回",LOGIN:"登录",LOGOUT:"退出登录",REGISTER:"注册",SETTINGS:"设置"}},l=(0,o.xr)((e=>{const{routes:n}=r["default"].init({...e,config:s.Z});n.push({path:"/:catchAll(.*)*",name:"page404",component:()=>t.e(456).then(t.bind(t,8456))||t.e(739).then(t.bind(t,77739))}),n.forEach((n=>{n&&n.path&&!n.path.startsWith("/")&&(n.path=`/${n.path}`),e.router.addRoute(n)})),e.store&&e.store.i18nMessages&&Object.keys(e.store.i18nMessages).forEach((n=>{i.i18n.global.setLocaleMessage(n,{...e.store.i18nMessages[n],...a[n]||{}})}))}))},60991:(e,n,t)=>{"use strict";t.r(n),t.d(n,{DEFAULT_LANGUAGE:()=>u,default:()=>h,getLocale:()=>c,i18n:()=>m});t(69665);var o=t(23340),r=t(27712),s=t(71947),i=t(3746),a=t(36278),l=t(37395);const d={"en-us":{error404:"Sorry, nothing here...",goback:"Go Back",LOGIN:"Login",LOGOUT:"Logout",REGISTER:"Register",SETTINGS:"Settings"},"zh-cn":{error404:"抱歉，此页面不存在...",goback:"返回",LOGIN:"登录",LOGOUT:"退出登录",REGISTER:"注册",SETTINGS:"设置"}};let u="";const c=()=>{let e=u||l.Z.defaultLocale||"zh-cn";if(!e){const n=s.Z.lang.getLocale().toLowerCase();l.Z.locales[n]&&(e=n)}return e||"zh-cn"};u=c();const m=(0,r.o)({legacy:!1,locale:"zh-cn",fallbackLocale:"zh-cn"}),h=(0,o.xr)((e=>{e.app.use((0,i.WB)());const n=(0,a.Z)(),t=n.locale||u||s.Z.lang.getLocale().toLowerCase()||"zh-cn";m.locale=t,m.fallbackLocale=t,u=t,e.app.config.globalProperties.i18n=m,e.app.use(m),e.app.i18nMessages?Object.keys(e.app.i18nMessages).forEach((n=>{m.global.setLocaleMessage(n,{...e.app.i18nMessages[n],...d[n]||{}}),l.Z.locales.findIndex((e=>e.locale===n))<0&&l.Z.locales.push({name:n,locale:n})})):console.error(e.app)}))},28953:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>o});const o={siteName:"FREE",backendURL:"http://127.0.0.1:8000/",baseUrl:"/api",defaultLocale:"zh-cn",defaultIcon:"",defaultImg:"",assetsBase:"/assets",imageUrlBase:"/assets/image/",thumbUrlBase:"/assets/thumb/",videoUrlBase:"/assets/misc/",documentUrlBase:"/assets/docs/",nanPlaceholder:"/",locales:[{locale:"zh-cn",name:"中文",calendar:{days:["星期一","星期二","星期三","星期四","星期五","星期六","星期日"],daysShort:["周一","周二","周三","周四","周五","周六","周日"],months:["一月","二月","三月","四月","五月","六月","七月","八月","九月","十月","十一月","十二月"],monthsShort:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],firstDayOfWeek:0}},{locale:"en-us",name:"English"}],i18n:{"en-us":{error404:"Sorry, nothing here...",goback:"Go Back",okButtonText:"OK",saveButtonText:"Save",cancelButtonText:"Cancel",deleteButtonText:"Delete",notifySaved:"Saved",notifySaveFailed:"Failed to save!",notifyDeleted:"Deleted",notifyDeleteFailed:"Failed to delete!",notifyChanged:"Changed",notifyChangeFailed:"Failed to change!",notifyAdded:"Added",notifyAddFailed:"Failed to add!",notifyNoPermission:"No permission!",notifyEnabled:"Enabled",notifyEnableFailed:"Failed to enable!",inputValidateFailed:"Form validation failed!"},"zh-cn":{error404:"抱歉，此页面不存在呀...",goback:"返回",okButtonText:"确定",saveButtonText:"保存",cancelButtonText:"取消",deleteButtonText:"删除",notifySaved:"保存成功！",notifySaveFailed:"保存失败！",notifyDeleted:"删除成功！",notifyDeleteFailed:"删除失败！",notifyChanged:"修改成功！",notifyChangeFailed:"修改失败！",notifyAdded:"添加成功！",notifyAddFailed:"添加失败！",notifyNoPermission:"没有权限操作！",notifyEnabled:"激活成功！",notifyEnableFailed:"激活失败！",inputValidateFailed:"数据校验失败！"}}}},83938:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>o});const o={modules:["free"]}},17237:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>o});const o={modules:["free"]}},66630:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>o});const o={}},37395:(e,n,t)=>{"use strict";t.d(n,{Z:()=>u});t(69665);var o=t(95019),r=t(28953);Object.merge=(e,...n)=>{const t=(e,n)=>{n=n||{},Object.keys(n).forEach((o=>{const r=n[o];Array.isArray(r)||"object"!==typeof r?e[o]=r:(e[o]=e[o]||{},t(e[o],r))}))};e=e||{};for(let o=0;o<n.length;o+=1)t(e,n[o]);return e},Object.hasValue=e=>{if([void 0,null].indexOf(e)>=0)return!1;if("object"!==typeof e&&e)return!0;if("object"===typeof e)for(let n=0;n<Object.keys(e).length;n+=1)if(Object.hasValue(e[Object.keys(e)[n]]))return!0;return!1},Object.nestValue=(e,n)=>{if(!e||!n)return;if("."===n)return e;let t=e;const o=n.split(".");for(let r=0;r<o.length;r+=1){const e=o[r];if("object"!==typeof t[e])return t[e];t=t[e]}return t},Object.setValue=(e,n,t)=>{if(!e||!n)return;let o=e;const r=n.split(".");for(let s=0;s<r.length;s+=1){const e=r[s];s<r.length-1?(o[e]||(o[e]="number"===typeof r[s+1]?[]:{}),o=o[e]):o[e]=t}return e};const s=e=>{if("object"!==typeof e)return e;let n;if(e.__cycle_mark=1,Array.isArray(e)){n=[];for(let t of e)t.__cycle_mark||n.push(s(t))}else{n={};for(let t of Object.keys(e))e[t].__cycle_mark||(n[t]=s(e[t]))}return delete e.__cycle_mark,delete n.__cycle_mark,n};Object.decycle=e=>{if("object"!==typeof e)return e;const n=Array.isArray(e)?(0,o.Z)(!0,[],e):(0,o.Z)(!0,{},e);return s(n)};const i={},a=t(42020),l=a.keys();for(let c=0;c<l.length;c+=1){let e=l[c];e=e.substr("./config.".length),e=e.substr(0,e.length-3),e&&!i[e]&&(i[e]=a(l[c]).default)}const d=Object.merge(r["default"],i["production"]),u=d},62488:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>u});var o=t(59835);const r="## Specification\n\nIn FreeEIS, any function should be implemented as a separate module, and these independent modules can usually run independently, and module developers can develop and debug by themselves, without relying on other parts. The person responsible for integration only needs to associate each functional module into a unified integration environment, configure each functional module as needed, and run the entire system.\n\nHowever, FreeEIS also implements module-to-module extension to meet the needs of `module plug-ins`, in which case newly developed `plug-in` modules need to be carried out in the presence of the extended module. In this case, the module cannot really be completely independently developed and run, but considering that the new module is an extension of an existing module, and the two modules can be considered as a whole, we can still say that it is independently developed and run.\n\nThis is the first core idea of FreeEIS development.\n\n## Prerequisites\n\nThe FreeEIS backend is developed based on ExpressJS, so you need to have some understanding of ExpressJS, which is a NodeJS-based backend framework that includes routing, middleware and other features, so you also need to have a deeper understanding of NodeJS. In the current version, we use ExpressJS 4.x.\n",s='## Scaffolding\n\nFreeEIS back-end development began with FreeEIS scaffolding works. Scaffolding engineering as the basis of module development, but also the basis of system integration, the operation of any module needs to be completed through scaffolding engineering.\n\n### run\n\n```sh\n# Install back-end scaffolding\n$ git clone https://github.com/freeeis/free-be-starter-kit.git be\n\n# Install dependent packages\n$ cd be\n$ yarn install\n\n# Run\n$ yarn start\n```\n\nAt this point, you can access the interface `http://localhost:8000/api/nothing` through the browser and you will get the return result `{"data":{},"msg":"OK"}`, indicating that your back-end scaffolding has been successfully run.\n\nIt should also be noted that in the scaffolding, some built-in modules are added by default, and there will be detailed instructions on how to disable built-in modules before starting the actual development content in later chapters to create your own modules from a more "clean" environment.\n\n### Directory structure\n\nThe FreeEIS scaffolding directory structure is as follows:\n\n```\n---.app\n  --.bin\n  -- config\n    -- config.default.js\n    -- config.development.js\n    -- config.production.js\n    -- config.test.js\n  -- modules\n  -- test\n  -- utils\n  -- app.js\n  -- global.js\n\n```\n\nIn this directory structure:\n  - `bin`, FreeEIS runs the entry point for different environments.\n  - `config`, the configuration file storage location, used to configure the global configuration information in different operating environments in FreeEIS, and can also be used to override the default configuration of each module to achieve the goal of customizing the use of modules. By default we put in configuration files for three environments, development, test, and production, but you can extend it according to your needs.\n    - `config.default.js`, the default configuration, configuration information common to all environments, or default configuration information. will be overwritten (or expanded) by the configuration information for the specific runtime environment below.\n    - `config.development.js`, configuration information in the development environment.\n    - `config.production.js`, configuration information in the production environment.\n    - `config.test.js`, configuration information in the test environment.\n  - `modules`, the FreeEIS module storage directory, modules can be saved directly in this directory, or referenced using functions such as git submodule.\n  - `test`, the test code directory.\n  - `utils`, the directory where global tools methods are stored. We do not recommend using global tools, because that will result in some modules not being developed independently and will have to rely on the project that owns the tool, but extracting utilities is necessary in some special cases, so we have retained this ability.\n  - `app.js`, the code entry, calls the FreeEIS kernel module and loads and runs other modules as needed.\n  - `global.js`, the global key storage file, this file saves confidential information such as keys required by each module in the system, and should not be uploaded to the code repository!! When deploying, you should secure confidential information by manually writing to the server, for example.\n\n### Things that can be done\n\nWhen the scaffolding project is successfully run, we can already start the actual development work, and we can do these things:\n\n- Modify the configuration information of the corresponding environment in the `config` directory as needed.\n - Add new functional modules in the `modules` directory.\n - Add global tools in the `utils` directory.\n\nHowever, these tasks do not necessarily need to be done in the usual development process, and when we consider the different developer roles, we can split them as follows:\n\n#### Module developer\n\nModule developers typically only need to:\n\n- Add new functional modules in the `modules` directory.\n\n#### System integrators\n\nSystem integrators typically need to:\n\n- Modify the configuration information of the corresponding environment in the `config` directory as needed.\n - Introduce the required functional modules in the `modules` directory.\n\nWe will introduce each of them in detail.\n\n',i="## Module development\n\n### Modify the startup module\n\nAs mentioned earlier, module developers may need to disable built-in modules to get a \"clean\" environment to create their own modules. To disable built-in modules, or modify modules that need to be started, you can do so by modifying `config/config.development.js`, as follows:\n\n```javascript\nexport default {\n  modules: [\n    // {\n         name: 'db',\n         path: 'free-be-mongodb',\n    // },\n     'account',\n     'core-modules',\n     'demo',\n  ],\n  ...\n};\n\n```\n\nThe `modules` here is the list of modules that need to be started, and the scaffolding starts the `mongoDB`, `account`, `core-modules`, `demo` modules by default, and here we remove them from the `modules` list to disable them. The reference to the database module here is in the form of an object, and the use of this method will be described in more detail later.\n\n\n### Create the module\n\nNext we create a new module and add a subdirectory `my-first-module` to the `modules` directory, with the following directory structure:\n\n```\n-- src\n  -- modules\n    -- my-first-module\n      -- index.js\n      -- routers\n        -- index.js\n        -- route.js\n```\n\nwhere `index.js` is the entry file for our new module, which contains the following:\n\n```javascript\n my-first-module/index.js\nmodule.exports = {};\n```\n\nThe directory routers is the interface code directory, from which FreeEIS automatically loads the interface definition hierarchically. Among them, `index.js` is some definition content that each directory level in the `routers` directory needs to have directly to the current interface level, and in more detail later, the empty object is returned first.\n\n```javascript\n my-first-module/routers/index.js\nmodule.exports = {};\n```\n\nThe `route.js` is the interface definition code file. FreeEIS will load all the `js` files in these directories except `index.js` as interface definition code files, so we can split the interfaces under the same level into multiple code files as needed, and the names can be defined as needed. Here we only have a `route.js` file that returns the `router` object for `ExpressJS`, but there is no interface defined in that object.\n\n```javascript\n my-first-module/routers/route.js\n\nconst path = require(\"path\");\nconst express = require(path.resolve('./') + \"/node_modules/express\");\nconst router = express. Router();\n\nmodule.exports = router;\n```\n\nWe already have a new module, and to get it started, I need to add it to `modules` in `config.development.js`.\n\n```javascript\n\nexport default {\n  modules: [\n    'my-first-module'\n  ],\n};\n\n```\n\nAt this point, our module is empty and does not have any interfaces. Next, we create the interface and add the interface definition in the `route.js`:\n\n```javascript\n modules/my-first-module/routers/route.js\n\nconst path = require(\"path\");\nconst express = require(path.resolve('./') + \"/node_modules/express\");\nconst router = express. Router();\n\nrouter.get('', (req, res, next) => {\n    res.addData(`hello world`);\n\nreturn next();\n})\n\nmodule.exports = router;\n```\n\nAt this point, we have an interface in our module, but we don't know how to call it. FreeEIS allows back-end modules not to expose interfaces, so in modules that need to expose interfaces, we need to explicitly tell FreeEIS. Let's modify the module entry file as follows:\n```javascript\n my-first-module/index.js\n\nmodule.exports = {\n    config: {\n        asRouteService: true, // tells FreeEIS that this module will provide interface routing services\n        routeRoot: 'mymodule',// When the module provides interface routing services, we need to tell FreeEIS what the interface root path of this module is.\n    },\n}\n```\n\nRestart the backend service and access `http://localhost:8000/api/mymodule` through your browser, you will get `{'data': \"hello world\",\"msg\":\"OK\"}`.\n\nThere are a few days to note here:\n\n- FreeEIS automatically loads hierarchical interface definitions from the `routers` directory in the module, so no additional work is required to automatically expose the interfaces defined therein.\n - FreeEIS automatically prepends `/api` to all interfaces as a prefix for backend interfaces, which can be controlled by modifying `baseUrl` in `config/config.default.js`. Another advantage of this prefix is that when we have multiple versions of backend services, or when multiple services cooperate to provide backend support, we can distinguish different sets of interfaces by defining different prefixes.\n - Modules that need to expose interface routing need to explicitly configure the corresponding configuration items, otherwise the interfaces in the module will not be loaded.\n\n### Dynamic data\n\nAt this point we have successfully defined a new FreeEIS backend module, exposed a new interface, and returned some data. But in more common cases, the content that the interface needs to return is mutable, which has two cases: one is that some content comes through configuration; The second is that some content comes through databases. We introduce them separately.\n\n#### Module configuration\n\nIn our instance module, assuming that the target we need hello is not a fixed `world`, but needs to be determined by the situation, then we can add the corresponding configuration parameters in the module to make this part variable.\n\nLet's add the following configuration definition to the module entry file (this definition can be stripped out and placed in any other file):\n```javascript\n my-first-module/index.js\n\nmodule.exports = {\n    config: {\n        asRouteService: true,\n        routeRoot: 'mymodule',\n\ngreetingTo: 'world',\n    },\n}\n```\n\nWe reference this configuration parameter in the interface code:\n\n```javascript\n modules/my-first-module/routers/route.js\n\nconst path = require(\"path\");\nconst express = require(path.resolve('./') + \"/node_modules/express\");\nconst router = express. Router();\n\nrouter.get('', (req, res, next) => {\n    res.addData(`hello ${router.mdl.config.greetingTo}`);\n\nreturn next();\n})\n\nmodule.exports = router;\n```\n\nHere, we access the configuration parameters defined above via `router.mdl.config.greetingTo`. FreeEIS automatically changes the instance of the current module to `router.mdl`, so we can access all the information defined in the current module entry file.\n\nRestart the backend service and access `http://localhost:8000/api/mymodule` through the browser, you will still get `{\"data\": \"hello world\", \"msg\": \"OK\"}`, but the `world` here is dynamic content.\n\n#### Database\n\nAlternatively, the data comes from a database. If our module requires database support, then we need to define the required data model first, which is very simple in the FreeEIS backend, just define it like this in the entry file of the module:\n\n```javascript\n my-first-module/index.js\n\nmodule.exports = {\n    config: {\n        asRouteService: true,\n        routeRoot: 'mymodule',\n\ngreetingTo: 'world',\n    },\n    data: {\n        world: {\n            Name: { type: 'String', required: true },\n            Size: { type: 'String', default: 'large', },\n        },\n    },\n}\n```\n\nIn the above code, we have added a data model called `world` to the current module, which contains two fields, `Name` and `Size`. In this way, FreeEIS automatically generates the corresponding data model for us. Next, we call this data model from our interface code:\n\n```javascript\n my-first-module/routers/route.js\n\n...\nrouter.get('/', async (req, res, next) => {\n    const worldsCount = await res.app.models.world.countDocuments({});\n    res.addData(`hello ${worldsCount} worlds`);\n\nreturn next();\n})\n...\n\n```\nIn the above code, we access our newly defined data model through `res.app.models.world` and call the `countDocuments` method to return the number of data bars.\n\nHowever, restarting the service does not get the desired result, because the support for the database in FreeEIS also exists as a separate module, and FreeEIS provides built-in `MongoDB` database support by default, which needs to be enabled by adding it to the `modules` list of `config/config.development.js`:\n\n```javascript\nexport default {\n  modules: [\n    {\n        name: 'db',\n        path: 'free-be-mongodb',\n    },\n    'my-first-module'\n  ],\n};\n\n```\n\nHere, we need to pay attention to the order of the items in the `modules` list, because our `my-first-module` needs to use the capabilities in the `mongoDB` module, so we need to put the `mongodb` module first to load first. Another way to achieve this is to add the `mongoDB` module to the `my-first-module` dependency list:\n\n```javascript\n  ...\n  config: {\n      asRouteService: true,\n      routeRoot: 'mymodule',\n      dependencies: [\n          'db'\n      ],\n\ngreetingTo: 'world',\n  },\n\n...\n```\n\nIn this way, when FreeEIS loads the module list, even if the `db` module is after the `my-first-module` module, it will load `db` first to ensure that all modules are loaded with the correct dependencies.\n\nThe `db` module we use here is `free-be-mongodb`, but in reality, we may use other databases, so we need to introduce another database module, such as `freeeis-mysql`, then the way we introduce this database module should be:\n```javascript\n\nexport default {\n  modules: [\n    {\n        name: 'db',\n        path: 'freeeis-mysql',\n    },\n    'my-first-module'\n  ],\n};\n\n```\n\nThat's why we allow the use of objects in the module list, because a more generic module like `db` may have multiple implementations, which makes a module like `my-first-module` only need to declare that it depends on the `db` module, and does not need to care which database module the system integrator is using. Of course, this requires that all database modules expose the same interface or method, which is explained in detail when talking about database modules in built-in modules.\n\n### Module consumers override module configuration items\n\nGoing back to our interface definition file, change it to:\n\n```javascript\n my-first-module/routers/route.js\n\n...\nrouter.get('/', (req, res, next) => {\n    res.addData(`hello ${router.mdl.config.greetingTo}`);\n\nreturn next();\n})\n\nrouter.get('/count', async (req, res, next) => {\n    const worldsCount = await res.app.models.world.countDocuments({});\n    res.addData(`hello ${worldsCount} worlds`);\n\nreturn next();\n})\n\n...\n```\n\nHere we returned a string with `greetingTo` in the first interface. At this point, assuming that our `my-first-module` has already been developed, the system integrator or other developer who wants to use this module may need more control over the `greetingTo` configuration items we have defined, and he can do this:\n\n```javascript\n config/config.development.js\n\nexport default {\n  modules: [\n    'my-first-module',\n    {\n        name: 'db',\n        path: 'free-be-mongodb',\n    },\n  ],\n\n'my-first-module': {\n    greetingTo: 'FreeEIS'\n  },\n};\n\n```\n\nAt this point, restart the backend service and access `http://localhost:8000/api/mymodule` through the browser, you will get `{\"data\": \"hello FreeEIS\",\"msg\": \"OK\"}`. This gives the system integrator or module user full freedom to control the variable parameters of the module.\n\n### Multi-language support\n\nThe FreeEIS backend also supports multiple languages to deal with translation issues when some fixed strings are returned from the backend.\n\nContinuing with the module we created above, assuming we need Chinese and English support for the word `hello`, we need to add the definition of the corresponding translation dictionary to the module entry file:\n\n```javascript\n  ...\n  config: {\n      asRouteService: true,\n      routeRoot: 'mymodule',\n      dependencies: [\n          'db'\n      ],\n\ngreetingTo: 'world',\n  },\n  i18n: {\n      'en-us': {\n          hello: 'hi',\n      },\n      'zh-cn': {\n          hello: 'Hello',\n      },\n  },\n\n...\n\n```\n\nThe `i18n` here can obviously also be spun out for separate storage and introduced here.\n\nAt this point, restart the backend service and access `http://localhost:8000/api/mymodule` through the browser, you will get `{\"data\": \"Hello FreeEIS\",\"msg\": \"OK\"}`. The FreeEIS backend will also use Chinese as the default language when it is not sure of the current translation language.\n\nWe can control the translation language by modifying `app.ctx.locale` or passing in the `t()` function as a second parameter:\n\n```javascript\n my-first-module/routers/route.js\n\n...\nrouter.get('/', (req, res, next) => {\n    res.app.ctx.locale = 'en-us';\n\nres.addData(`${router.mdl.t('hello', 'en-us')} ${router.mdl.config.greetingTo}`);\n\nreturn next();\n})\n\n...\n```\n\nBut here, only schematically, the more common way is to decide which language to use for translation through the current language passed in on the front end. Like what:\n\n```javascript\n my-first-module/routers/route.js\n\n...\nrouter.get('/', (req, res, next) => {\n    const locale = req.query.locale;\n\nres.addData(`${router.mdl.t('hello', locale)} ${router.mdl.config.greetingTo}`);\n\nreturn next();\n})\n\n...\n```\nWhen we have more languages to support, just add the corresponding translation dictionary in i18n. For example, let's add another language, as follows:\n\n```javascript\n  ...\n  i18n: {\n      'en-us': {\n          hello: 'hi',\n      },\n      'zh-cn': {\n          hello: 'Hello',\n      },\n      'Martian': {\n          hello: '🚀🚀🚀',\n      },\n  },\n  ...\n```\n\nWe translate `hello` directly in `Mars`:\n\n```javascript\n my-first-module/routers/route.js\n\n...\nrouter.get('/', (req, res, next) => {\n    res.addData('${router.mdl.t('hello', 'Mars')} ${router.mdl.config.greetingTo}');\n\nreturn next();\n})\n\n...\n```\n\nAt this point, restart the backend service and access `http://localhost:8000/api/mymodule` through the browser, you will get `{\"data\": \"FreeEIS\", \"msg\": \"🚀🚀🚀 OK\"}`.\n",a="\n## System integration\n\nSystem integration developers have different goals than module developers, and they need to integrate the functional modules together as needed so that they can work together.\n\nFunctional modules can be introduced in three ways:\n\n- Publicly available modules can be added to package.json via `yarn add`.\n - Private modules can directly place modules in the `modules` directory.\n - Modules developed by remote developers that are placed in a separate code base can be added to the `modules` directory via `git submodule`.\n\nFor example, we added three modules:\n\n- Free-be-core-modules, modules that have been publicly released.\n - my-first-module, a module that we developed ourselves directly into the modules directory.\n - my-second-module, a module developed by another developer in a separate repository.\n\nWith the introduction of these three modules, the directory structure of our integration project is as follows:\n\n```\n--.app\n  -- node_modules\n    free-be-core-modules, added via `yarn add free-fe-core-modules`. (Added in scaffolding)\n  -- modules\n    -- my-first-module, which is a local directory where the module code is located.\n    my-second-module, which is a remote library added via `git submodule`.\n```\n\n### Enable the required modules\n\nThe introduced modules will not be loaded and run by default, if you need to load and run them, you need to add them to the modules of config, and the modules added in the three ways mentioned above are all started in the same way. Like this:\n\n```javascript\n config/config.development.js\n\nexport default {\n  modules: [\n    {\n        name: 'db',\n        path: 'free-be-mongodb',\n    },\n    'core-modules',\n    'my-first-module',\n    'my-second-module',\n  ],\n\n'my-first-module': {\n    greetingTo: 'China'\n  },\n};\n\n```\n\nHere you may notice that we added a module called `core-modules` because modules with names starting with `free-be-` can omit this prefix when introduced. But we don't recommend that you use such a naming method to name your own modules, as they are reserved for FreeEIS built-in modules.\n\n",l="## Built-in modules\n\n```Documentation is updating.........```\n",d="## High-level features\n\n```Documentation is updating.........```\n",u={c:`${r}${s}${i}${a}${l}${d}`,preComponents:[(0,o.h)("h1",{class:"text-center q-mb-xl"},["FreeEIS 后端开发"]),(0,o.h)("p",{align:"center"},[(0,o.h)("img",{src:"https://user-images.githubusercontent.com/33030594/227073920-03ed137f-c4f7-4ed7-ae05-d781dd1991f7.png",alt:"FreeEIS",width:"250"})])]}},90824:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>p});var o=t(60499),r=t(59835),s=t(97052),i=t(41694),a=t(70335),l=t(38346);const d='## Specification\n\nIn FreeEIS, any function should be implemented as a separate module, and these independent modules can usually run independently, and module developers can develop and debug by themselves, without relying on other parts. The person responsible for integration only needs to associate each functional module into a unified integration environment, configure each functional module as needed, and run the entire system.\n\nHowever, FreeEIS also implements module-to-module extension to meet the needs of "module plug-ins", in which case newly developed "plug-in" modules need to be carried out in the presence of the extended module. In this case, the module cannot really be completely independently developed and run, but considering that the new module is an extension of an existing module, and the two modules can be considered as a whole, we can still say that it is independently developed and run.\n\nThis is the first core idea of FreeEIS development.\n\n## Prerequisites\n\nThe FreeEIS front-end is based on the Quasar Framework, so you need to have some understanding of the Quasar Framework, which is a VUE-based front-end framework that includes features such as component libraries and cross-platform support, so you also need to have a deeper understanding of VUE. In the current version, we use Quasar Framework 2.x, which is based on VUE3.x.\n\nIn order to develop applications with FreeEIS, you may also need to know a few things about Webpack and NodeJS itself. But because both VUE and the Quasar Framework are wrapped further, you don\'t need to be aware of their existence in general.\n',u='## Scaffolding\n\nFreeEIS front-end development began with FreeEIS scaffolding engineering. FreeEIS front-end scaffolding project is based on the scaffolding project of Quasar Framework, but the FreeEIS kernel module is embedded, and then the loading and running of the FreeEIS module is realized.\n\nScaffolding engineering as the basis of module development, but also the basis of system integration, the operation of any module needs to be completed through scaffolding engineering.\n\n### run\n\n```sh\n# Install front-end scaffolding\n$ git clone https://github.com/freeeis/free-fe-starter-kit.git fe\n\n# Install dependent packages\n$ cd fe\n$ yarn install\n\n# Run\n$ yarn start\n```\n\nAt this point, you can view the system page through `http://localhost:8080`, but please note the terminal output, other ports such as 8081 may be used when port 8080 is already occupied.\n\nIt should also be noted that in the scaffolding, some built-in modules are added by default, and some built-in modules need the support of the corresponding back-end modules, and due to some historical reasons, there is not enough Mock information when these built-in modules are developed, so running the front-end scaffolding alone may report errors when calling some interfaces. We will gradually add mock content so that these built-in modules can also run off the backend. Later chapters will explain in detail how to disable built-in modules to create your own modules from a more "clean" environment before starting with the actual development content.\n\n### Directory structure\n\nThe FreeEIS scaffolding directory structure is as follows:\n\n```\n--- app\n   -- ...\n   -- public\n   -- src\n      App.vue\n      Error404.vue\n      -- boot\n      -- config\n          -- config.default.js\n          -- config.development.js\n          -- config.production.js\n          -- config.test.js\n          index.js\n      -- css\n          app.scss\n          quasar.variables.scss\n      -- modules\n      -- router\n      -- stores\n      -- utils\n      ...\n  ...\n\n```\n\n\nIn this directory structure, there are many definitions of the Quasar Framework, please refer to [Official Documentation] (https://quasar.dev), we will only cover the parts that are directly relevant when developing FreeEIS applications:\n- `public`, this directory is a static resource directory, image icons or other static resources are placed here, the contents of this directory will be copied directly to the output directory after compilation. But based on our development specifications, we should try to avoid using globally common resources and instead place them in each module, but we can still do this in some special cases.\n- `src`, which is the directory where the development code is stored.\n  - `App.vue`, which is the entry vue file and usually does not need to be modified.\n  - `Error404.vue`, which is the page displayed when the specified page is not found to report 404.\n  - `boot`, this is where the boot file of the Quasar Framework is stored, see Quasar Framework for details on boot files. We added the necessary documentation to support the launch of FreeEIS.\n  - `config`, the configuration file storage location, used to configure the global configuration information in different operating environments in FreeEIS, and can also be used to override the default configuration of each module to achieve the goal of customizing the use of modules. By default we put in configuration files for three environments, development, test, and production, but you can extend it according to your needs.\n    - `config.default.js`, the default configuration, configuration information common to all environments, or default configuration information. will be overwritten (or expanded) by the configuration information for the specific runtime environment below.\n    - `config.development.js`, configuration information in the development environment.\n    - `config.production.js`, configuration information in the production environment.\n    - `config.test.js`, configuration information in the test environment.\n    - `index.js`, configuration information entry, this file automatically loads the configuration files of all configuration environments in the current directory, and uses the corresponding configuration according to the current running environment.\n  - `css`, where the global style file is saved. We recommend using FreeEIS\'s style skin module while minimizing defining global styles here. But for obvious reasons, we keep the functionality here. The style skin module is a special type of module that specifically defines different style skins, which will be introduced in detail later.\n    - `app.scss`, global style entry.\n    - `quasar.variables.scss`, a global style variable definition file, which allows global style variables to standardize the design of module styles as a whole.\n  - `modules`, the FreeEIS module storage directory, modules can be saved directly in this directory, or referenced using functions such as git submodule.\n  - `router`, the routing portal.\n  - `stores`, state management entry, we use Pinia in the current version.\n  - `utils`, the directory where global tools methods are stored. We do not recommend using global tools, because that will result in some modules not being developed independently and will have to rely on the project that owns the tool, but extracting utilities is necessary in some special cases, so we have retained this ability.\n\n\n### Things that can be done\n\nWhen the scaffolding project is successfully run, we can already start the actual development work, and we can do these things:\n\n- Add global static resources in the `public` directory.\n - Modify the configuration information of the corresponding environment in the `config` directory as needed.\n - Add new functional modules in the `modules` directory.\n - Modify global styles in the `css` directory.\n - Add global tools in the `utils` directory.\n\nHowever, these tasks do not necessarily need to be done in the usual development process, and when we consider the different developer roles, we can split them as follows:\n\n#### Module developer\n\nModule developers typically only need to:\n\n- Add new functional modules in the `modules` directory.\n\n#### System integrators\n\nSystem integrators typically need to:\n\n- Modify the configuration information of the corresponding environment in the `config` directory as needed.\n - Introduce the required functional modules in the `modules` directory.\n\nWe will introduce each of them in detail.\n\n',c="## Module development\n\n### Modify the startup module\n\nAs mentioned earlier, module developers may need to disable built-in modules to get a \"clean\" environment to create their own modules. To disable built-in modules, or modify modules that need to be started, you can do so by modifying `src/config/config.development.js`, as follows:\n\n```javascript\nexport default {\n  modules: [\n     'main'\n  ],\n};\n\n```\n\nThe `modules` here is the list of modules that need to be started, and the scaffolding starts the `main` module by default, which is a schematic \"encapsulated module\" for more granular control over the other modules that are launched. More on \"encapsulating modules\" will be provided later, and here we only need to remove it from the `modules` list to disable it.\n\n\n### Create the module\n\nNext we create a new module and add a subdirectory `my-first-module` to the `modules` directory, with the following directory structure:\n\n```\n-- src\n  -- modules\n    -- my-first-module\n      -- index.js\n```\n\nwhere `index.js` is the entry file for our new module, which contains the following:\n\n```javascript\nimport { defineComponent, h } from 'vue';\n\nexport default {\n  routers: [\n    {\n      path: '/',\n      component: defineComponent({\n        name: 'MyComp',\n        setup() {\n          return ()  => h('div', {\n            class: 'absolute-center text-h3'\n          }, ['hello world']);\n        },\n      }),\n    },\n  ],\n};\n```\n\nWe already have a new module, and to get it started, I need to add it to `modules` in `config.development.js`.\n\n```javascript\n\nexport default {\n  modules: [\n    'my-first-module'\n  ],\n};\n\n```\n\nAt this point, go back to the browser and visit `http://localhost:8080` (or follow the terminal prompts to access the corresponding port), and you will see the text `hello world`, which is the first page in our module.\n\nHere, I wrote the page, route, module entry in the same file, which works, but as a general best practice, we should split them up. FreeEIS does not have a mandatory specification for how to split the organization code inside a module, you can develop it according to your own habits, as long as you indicate the routes that need to be exposed in the module entry file.\n\nThe following is the structure of multiple files after we split it, and the result is exactly the same as the effect of our single file above.\n\n```\n-- src\n  -- modules\n    -- my-first-module\n      -- index.js # This is still our module entry file\n      -- view # We put the \"view\" file in this directory\n        -- hellowWorld.vue # This is our hello world page\n      -- routes # We put the part that defines the route in this directory\n        -- index.js # This defines our route\n```\n\nThereinto:\n\n```javascript\n my-first-module/index.js\n\nimport routers from './routers';\n\nexport default {\n  routers,\n};\n\n```\n\n```vue\n\x3c!-- my-first-module/view/helloWorld.vue --\x3e\n\n<template>\n  <div class=\"absolute-center text-h3\">hello world</div>\n</template>\n\n<script>\nimport { defineComponent } from 'vue';\n\nexport default defineComponent({\n  name: 'HelloWorldPage',\n})\n<\/script>\n\n```\n\n\n```javascript\n/* my-first-module/routers/index.js */\n\nexport default [\n  {\n    path: '/',\n    component: () => import('../view/helloWorld.vue'),\n  }\n];\n\n```\n\nThe above split is schematic, in complex modules, it needs to be determined according to the actual situation, but the core idea is that FreeEIS does not limit the way your code is organized, just make sure that the corresponding route can be found in the module entry file.\n\n\n### Module configuration\n\nComponents or pages have `props` that allow our users to control certain content or logic, and modules also need such mechanisms.\n\nIn our instance module, assuming that the target we need hello is not a fixed `world`, but needs to be determined by the situation, then we can add the corresponding configuration parameters in the module to make this part variable.\n\nLet's add the following configuration definition to the module entry file (but again, this definition can be stripped out and placed in any other file):\n\n```javascript\n// my-first-module/index.js\n\nimport routers from './routers';\n\nexport default {\n  config: {\n    greetingTo: 'world',\n  },\n  routers,\n};\n```\n\nWe can refer to this configuration parameter in the component code as follows:\n\n```vue\n\x3c!-- my-first-module/view/helloWorld.vue --\x3e\n\n<template>\n  <div class=\"absolute-center text-h3\">hello {{greetingTo}}</div>\n</template>\n\n<script>\nimport { defineComponent, ref, getCurrentInstance, watchEffect } from 'vue';\n\nexport default defineComponent({\n  name: 'HelloWorldPage',\n  setup() {\n    const { proxy: { ctx } } = getCurrentInstance();\n    const greetingTo = ref('');\n\n    watchEffect(() => {\n      greetingTo.value = ctx.config['my-first-module'].greetingTo;\n    })\n\n    return {\n      greetingTo,\n    };\n  },\n})\n<\/script>\n\n```\n\nIf you don't use the combined API, you can access the global context through `this.ctx`, which includes two important things:\n\n- `ctx.config`, the global configuration information currently in effect, including the configuration information loaded from the `config` directory according to the current environment, as well as the configuration information of each module, such as the `greetingTo` we configured above can be accessed through `ctx.config['my-first-module'].greetingTo`.\n - `ctx.modules`, a list of all loaded modules, i.e. you can access all loaded modules, which makes it possible to use or extend existing modules.\n\n### Module consumers override module configuration items\n\nAssuming our `my-first-module` has already been developed, the system integrator or other developer who wishes to use this module may need more control over the `greetingTo` configuration items we have defined, and he can do this:\n\n```javascript\n// src/config/config.development.js\n\nexport default {\n  modules: [\n    'my-first-module',\n  ],\n\n  'my-first-module': {\n    greetingTo: '中国'\n  },\n};\n\n```\n\nAt this point, back in the browser, we can see that `hello 中国` has been displayed on the page.\n\n### Interface request\n\nAbove we demonstrate how to create a new module and define mutable configuration items in the module, but another common scenario is that some data on the front end comes from the backend interface.\n\nLet's continue to assume that in our new module, the content of greetingTo comes from a `POST` interface called `myModule/doSomething`, and we modify our helloWorld component as follows:\n\n```vue\n\x3c!-- my-first-module/view/helloWorld.vue --\x3e\n\n<template>\n  <div class=\"absolute-center text-h3\">hello {{greetingTo}}</div>\n</template>\n\n<script>\nimport { defineComponent, ref, getCurrentInstance } from 'vue';\n\nexport default defineComponent({\n  name: 'HelloWorldPage',\n  setup() {\n    const { proxy:vm } = getCurrentInstance();\n    const greetingTo = ref('');\n\n    vm.postRequest('/myModule/doSomething').then((d) => {\n      greetingTo.value = d?.greeting || '中国';\n    })\n\n    return {\n      greetingTo,\n    };\n  },\n})\n<\/script>\n```\n\nThe page reports an error because this interface does not exist. This requires the use of the mock function. Let's add mock code to our module entry file as follows:\n\n```javascript\nimport routers from './routers';\n\nexport default {\n  config: {\n    greetingTo: 'world',\n  },\n  routers,\n  mock: (Mock) => {\n    Mock.mock('/myModule/doSomething', 'post', {\n      greeting: 'FreeEIS'\n    })\n  },\n};\n\n```\n\nAt this time, back to the browser, you can see that the page shows `hello FreeEIS`, in which case the front-end can be completely developed independently, without the support of the back-end, of course, there must be consistent specifications for both sides of the definition of the interface. If all goes well, when the backend interface development is complete, our page can naturally transition to the front-end and back-end connections.\n\n### Interface request method\n\nAbove we saw that with `vm.postRequest` we called an interface of type `post`, in fact, in `vm` (i.e. `this` in the case of non-composite APIs), we have the following method:\n\n - getRequest\n - postRequest\n - putRequest\n - deleteRequest\n\nThey call the interface of the corresponding method separately, and both can pass in the parameter object, but the parameter object when calling `get` will be parsed into the `query` string in the path, and the parameter object in the other calling methods will be sent as `body`. Like what:\n\n```javascript\nconst url = '/myModule/doSomething';\n\nvm.getRequest(url, { name: 'free' });\n// get /myModule/doSomething?name=free\n\nvm.postRequest(url, { name: 'free' })\n// post /myModule/doSomething ，body is: { name: 'free' }\n\nvm.putRequest(url, { name: 'free' });\n// put /myModule/doSomething ，body is: { name: 'free' }\n\nvm.deleteRequest(url, { name: 'free' });\n// delete /myModule/doSomething ，body is: { name: 'free' }\n```\n\n### Multi-language support\n\nFreeEIS uses `vue-i18n` to provide multi-language support, but we encapsulate it to make multi-language support easier.\n\nContinuing with the module we created above, assuming we need Chinese and English support for the word `hello`, we need to create an 18n directory and create a file with the following structure in it:\n\n```\n-- src\n  -- modules\n    -- my-first-module\n      -- i18n\n        -- zh-cn\n          - index.js  # Chinese Translate dictionary entry files\n        -- en-us\n          - index.js  # English translation dictionary entry file\n```\n\nThereinto:\n\n```javascript\n// i18n/zh-cn/index.js\n\nexport default {\n  hello: '你好'\n}\n```\n\n\n```javascript\n// i18n/en-us/index.js\n\nexport default {\n  hello: 'hi'\n}\n```\n\nThen translate in real-time at `helloWorld.vue`:\n\n\n```vue\n\x3c!-- my-first-module/view/helloWorld.vue --\x3e\n\n<template>\n  <div class=\"absolute-center text-h3\">{{$t('hello')}} {{greetingTo}}</div>\n</template>\n\n<script>\nimport { defineComponent, ref, getCurrentInstance } from 'vue';\n\nexport default defineComponent({\n  name: 'HelloWorldPage',\n  setup() {\n    const { proxy:vm } = getCurrentInstance();\n    const greetingTo = ref('');\n\n    vm.postRequest('/myModule/doSomething').then((d) => {\n      greetingTo.value = d?.greeting || '中国';\n    })\n\n    return {\n      greetingTo,\n    };\n  },\n})\n<\/script>\n```\n\nAt this point, go back to your browser and see `Hello FreeEIS`. Because FreeEIS uses Chinese by default when it cannot determine the language that you currently need to use.\n\nIn the following code, we add two buttons to switch the current language:\n\n\n```vue\n\x3c!-- my-first-module/view/helloWorld.vue --\x3e\n\n<template>\n  <div class=\"absolute-center text-h3\">\n    {{$t('hello')}} {{greetingTo}}\n\n    <div class=\"row justify-center q-gutter-md q-mt-lg\">\n      <q-btn label=\"中文\" @click=\"changeLocaleTo('zh-cn')\"></q-btn>\n      <q-btn  label=\"English\" @click=\"changeLocaleTo('en-us')\"></q-btn>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { defineComponent, ref, getCurrentInstance } from 'vue';\n\nexport default defineComponent({\n  name: 'HelloWorldPage',\n  setup() {\n    const { proxy:vm } = getCurrentInstance();\n    const greetingTo = ref('');\n\n    vm.postRequest('/myModule/doSomething').then((d) => {\n      greetingTo.value = d?.greeting || '中国';\n    })\n\n    return {\n      greetingTo,\n      changeLocaleTo: (l) => {\n        vm.$i18n.locale = l;\n      }\n    };\n  },\n})\n<\/script>\n\n```\n\nBack in the browser, you can switch languages with two buttons.\n\nThe built-in `free-fe-core-modules` module has some basic components, such as the `SelectLocales` component, that can be used to switch languages. We start this module by adding it to the configuration:\n\n\n```javascript\n// config/config.development.js\n\nexport default {\n  modules: [\n    'core-modules',\n    'my-first-module',\n  ],\n\n  'my-first-module': {\n    greetingTo: '中国'\n  },\n};\n\n```\n\n\nThen add the `SelectLocales` component to the `helloWorld` page, as follows:\n\n```vue\n<template>\n  <div class=\"absolute-center text-h3\">\n    {{$t('hello')}} {{greetingTo}}\n\n    <div class=\"row justify-center q-gutter-md q-mt-lg\">\n      <select-locales></select-locales>\n    </div>\n  </div>\n</template>\n```\nAt this time, go back to the browser and you can see the effect of the modification. The `SelectLocales` component displays an icon by default, and when clicked, the down menu appears to select the language, which is more suitable for places like the top menu bar.\n\nWhen we have more languages to support, just add the corresponding translation dictionary in the i18n directory, and it can be automatically added to the drop-down menu to achieve real-time translation. For example, let's add another language, as follows:\n\n\n```\n-- src\n  -- modules\n    -- my-first-module\n      -- i18n\n        -- zh-cn\n          - index.js  # Chinese Translate dictionary entry files\n        -- en-us\n          - index.js  # English translation dictionary entry file\n        -- 火星语\n          - index.js  # Martian translation dictionary entry file\n```\n\n\n```javascript\n// i18n/火星语/index.js\n\nexport default {\n  hello: '🚀🚀🚀'\n}\n\n```\n\nAt this time, go back to the browser, click the switch language button, you can see the `Martian language` option, select `Martian language` and the page content becomes `🚀🚀🚀 FreeEIS`.\n\nHowever, because Martians do not know Chinese three words `Martian language`, so although we earthlings define Martian language as `Martian language`, just as we define Chinese as `zh-cn`, then we need to display the meaning of the three words `Martian language` in the drop-down menu on the page, at this time we need to add this language to `locales` in the global configuration menu, such as the following:\n\n```javascript\n// config/config.default.js\n\n....\nlocales: [\n  ....,\n  {\n    name: '🚀🚀🚀',\n    locale: '火星语',\n  },\n],\n....\n\n```\n\nAt this point, back in the browser, you can see that the option of `🚀🚀🚀` automatically appears in the drop-down box, which is text that Martians can understand.\n\nNote that these configurations can vary depending on the runtime environment, and the same items configured in the runtime environment will override the items in `config.default.js`.\n\n",m="\n## System integration\n\nSystem integration developers have different goals than module developers, and they need to integrate the functional modules together as needed so that they can work together.\n\nFunctional modules can be introduced in three ways:\n\n- Publicly available modules can be added to package.json via `yarn add`.\n - Private modules can directly place modules in the `modules` directory.\n - Modules developed by remote developers that are placed in a separate code base can be added to the `modules` directory via `git submodule`.\n\nFor example, we added three modules:\n\n- Free-fe-core-modules, modules that have been publicly released.\n - my-first-module, a module that we developed ourselves directly into the modules directory.\n - my-second-module, a module developed by another developer in a separate repository.\n\nWith the introduction of these three modules, the directory structure of our integration project is as follows:\n\n```\n-- app\n  -- node_modules\n    -- free-fe-core-modules, added via `yarn add free-fe-core-modules`. (Added in scaffolding)\n  -- src\n    -- modules\n      -- my-first-module, which is a local directory where the module code is located.\n      -- my-second-module, which is a remote library added via `git submodule`.\n```\n\n### Enable the required modules\n\nThe introduced modules will not be loaded and run by default, if you need to load and run them, you need to add them to the modules of config, and the modules added in the three ways mentioned above are all started in the same way. Like this:\n\n```javascript\n// config/config.development.js\n\nexport default {\n  modules: [\n    'core-modules',\n    'my-first-module',\n    'my-second-module',\n  ],\n\n  'my-first-module': {\n    greetingTo: '中国'\n  },\n};\n\n```\n\nHere you may notice that we added a module called `core-modules` because modules with names starting with `free-fe-` can omit this prefix when introduced. But we don't recommend that you use such naming methods because they are reserved for built-in modules.\n\n### Encapsulate the module\n\nEarlier we mentioned the encapsulated module, which is a special kind of module. To say that he is special means that in addition to all the functions and features of a normal module, he also uses a special feature `reference route` to rearrange all the routes that need to be exposed. Let's give examples to illustrate how to use it.\n\nLet's make a copy of `my-first-module` and change the name to `my-second-module`, and change the `helloWorld` page in `my-second-module` to:\n\n```vue\n\x3c!-- modules/my-second-module/view/helloWorld.vue --\x3e\n\n<template>\n  <div class=\"absolute-center text-h3\">\n    hello from second module\n  </div>\n</template>\n\n<script>\nimport { defineComponent } from 'vue';\n\nexport default defineComponent({\n  name: 'SecondHelloWorldPage',\n})\n<\/script>\n\n```\n\nAnd change the routing path in `routers` in `my-second-module` to `/second`:\n\n\n```javascript\n// modules/my-second-module/routers/index.js\n\nexport default [\n  {\n    path: '/second',\n    component: () => import('../view/helloWorld.vue'),\n  }\n];\n\n```\n\nAt this point, we can visit `http://localhost:8080` and `http://localhost:8080/#/second` respectively through the browser to see the two pages in `my-first-module` and `my-second-module` respectively.\n\nHowever, we most likely don't want the routing path for both pages to look like this, but instead need to follow the overall plan of our more complex system. For example, we need to use `/hello/first` and `/hello/second` paths to access these two pages. Let's create a new module, called `wrapper`, with the following directory structure:\n\n```\n--- app\n  -- src\n    -- modules\n      -- wrapper\n        -- index.js\n```\n\n其中：\n\n```javascript\n// modules/wrapper/index.js\n\nexport default {\n  config: {\n    dependencies: [\n      'core-modules',\n      'my-first-module',\n      'my-second-module',\n    ],\n  },\n  routers: [\n    {\n      ref: 'my-first-module>firstHello',\n      path: '/hello/first',\n    },\n    {\n      ref: 'my-second-module>secondHello',\n      path: '/hello/second',\n    },\n  ],\n}\n\n```\nHere, we define `routers` in `wrapper` and apply routes from other modules by using definitions of the form `ref: [module name]> [route name]`, referencing the route is equivalent to copying the corresponding routing configuration of the referenced module here, but we can override the value in the referenced module by redefining a property like `path`.\n\nNote that here we added the `dependencies` list to let FreeEIS know that the `wrapper` module depends on these three modules so that they can be loaded before the `wrapper` module.\n\nAt this point, you will go to the browser and you will see an error because the `firstHello` and `secondHello` routes cannot be found from the two referenced modules based on the route name. Let's go back to the route definitions of the two referenced modules, modify them to the following form, and add the `name` definition:\n\n```javascript\n// modules/my-first-module/routers/index.js\n\nexport default [\n  {\n    path: '/',\n    name: 'firstHello',\n    component: () => import('../view/helloWorld.vue'),\n  }\n];\n\n```\n\n```javascript\n// modules/my-second-module/routers/index.js\n\nexport default [\n  {\n    path: '/second',\n    name: 'secondHello',\n    component: () => import('../view/helloWorld.vue'),\n  }\n];\n\n```\nAlso, modify the modules enabled in `config.development.js` as follows:\n\n```javascript\n// config/config.development.js\n\nexport default {\n  modules: [\n    'wrapper',\n  ],\n\n  'my-first-module': {\n    greetingTo: '中国'\n  },\n};\n\n```\n\nHere we tell FreeEIS to load only one module, `wrapper`, because we want the system not to load all the incoming modules directly, but to load them selectively in a more controlled way. The advantage of this is that when we have some routes in some modules that do not need to be exposed, we can not reference them in the route definition of `wrapper`, and we tell FreeEIS to load only the `wrapper` module, so that the system will only load according to the configuration in `wrapper`.\n\nFor example, let's add a new page to `my-second-module`:\n\n\n```javascript\n// modules/my-second-module/routers/index.js\n\nexport default [\n  {\n    path: '/second',\n    name: 'secondHello',\n    component: () => import('../view/helloWorld.vue'),\n  },\n  {\n    path: '/third',\n    name: 'thirdHello',\n    component: () => import('../view/helloWorld.vue'),\n  },\n];\n\n```\n\nIf we add `my-second-module` directly to the `modules` list of `config.development.js`, we can access the newly defined page by visiting `/third`, but after we only add `wrapper` to `modules` in `config.development.js`, we can't access the page because it's not there in `wrapper`'s route definition.\n\nIn addition, it should be noted that in order to reference the routes of other modules, we need to add the `name` attribute to the referenced routes to distinguish between different route definitions, which should be a default good practice, because module developers develop modules that are intended for use by system integrators or other developers.\n\n",h="## Built-in modules\n\n```Documentation is updating.........```\n",f=(0,o.iH)(1),p={c:`${d}${u}${c}${m}${h}`,preComponents:()=>{console.log(l.Z);const e=[1,2,3,4,5,6,7,8,9,10].map((e=>(0,r.h)(i.Z,{name:e,style:"height: 200px"},(()=>[(0,r.h)("div",{class:"row no-wrap items-center justify-center"},[l.Z.width<630?null:(0,r.h)(a.Z,{opacity:.6,height:"110px",width:"160px",src:`/images/${e-1||10}.png`}),(0,r.h)(a.Z,{class:"q-mx-md",height:"140px",width:"190px",src:`/images/${e}.png`}),l.Z.width<630?null:(0,r.h)(a.Z,{opacity:.6,height:"110px",width:"160px",src:`/images/${e+1>10?1:e+1}.png`})])]))));return[(0,r.h)("h1",{class:"text-center q-mb-xl"},["FreeEIS Frontend Development"]),(0,r.h)("div",{class:"row full-width items-center justify-center"},[(0,r.h)(s.Z,{class:"q-mt-md",height:"200px",style:"background: unset;max-width: 542px","transition-prev":"slide-right","transition-next":"slide-left",animated:!0,infinite:!0,swipeable:!0,autoplay:3500,modelValue:f.value,"onUpdate:model-value":e=>{f.value=e}},(()=>e))])]}}},56395:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>i});var o=t(90824),r=t(62488),s=t(7629);const i={fe:o["default"],be:r["default"],intro:s["default"]}},7629:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>r});const o='<p align="center">\n  <img\n    src="https://user-images.githubusercontent.com/33030594/227073920-03ed137f-c4f7-4ed7-ae05-d781dd1991f7.png"\n    alt="FreeEIS"\n    width="250"\n  />\n</p>\n\n\nFreeEIS is a scalable, enterprise-level information system development framework. FreeEIS is designed to solve the increasingly popular problem of system disassembly and assembly in remote collaborative development. And by accumulating more and more functional modules, the system is built faster.\n\n## Background\n```\n - Remote collaboration has become a clear trend, especially in the field of software development. Under the influence of the epidemic, this trend is becoming more and more pronounced. Many people actively or passively work from home to collaborate remotely with their teams.\n - Freelancing is another trend, and more and more people will prefer to freely choose short-term work content rather than being "tied to" an organization for a long time.\n - Many enterprises, especially small and medium-sized software enterprises, are facing the problem of difficult management of technical teams. On the one hand, remote work increases the cost of team communication, and on the other hand, the collaboration of different types of team members (local, remote, part-time, etc.) makes it difficult to split the project.\n```\n\n## Target\n\nWe expect to achieve the following goals:\n - Anyone with a basic technical background can quickly set up a working web system and focus on designing new features in specific areas!!\n - "Force" developers to build universally available functional modules to improve reuse and reduce subsequent costs.\n - Full front-end and back-end support, full-stack, detachable.\n - Easily split a large project into multiple independent modules and assign them to any type of team member without developers having to think about other parts of the system.\n - Each module is flexible and scalable enough to be a massive system in its own right, a small reusable component or just a simple tooling approach.\n - Modules are completely independent of each other.\n - Modules can work together with simple (or no configuration) between them.\n - By implementing basic functional modules, the general project only needs to consider the business logic of the specific domain.\n - Through certain specifications, functional modules developed by anyone can be directly referenced.\n - Expand domain-specific functional modules to simplify the implementation of industry solutions.\n\n## Structure\n\nFreeEIS believes that any functional module can be universal, but the scope of the general is different. If the generality is not considered in the development, the cost of doing as many projects as many projects is equally high, and if the generality is considered, the development cost will decrease as the number of accumulated modules increases. (Reuse is a very common concept in the developer\'s head, but in reality, it is not easy to do well.) We allow a module to be bad, but make it very easy to replace or modify a bad module. ）\n\nFreeEIS was defined as: one base + one set of generic modules + one set of custom modules = one system.\n\n - A pedestal that refers to the kernel module and project scaffolding.\n - A set of general modules, which refer to the functions that need to be considered in most systems, such as dictionary management, log management, menu management, system configuration management, error code management, account management, organization management, role management, permission control, etc. FreeEIS will gradually implement these common functional modules, expanding the scope where possible.\n - A set of customized modules, which refers to the "non-generic" functional modules in specific business needs, which need to be customized and developed by the development team according to customer needs. However, in the development of these modules, it is still possible to consider implementing them as "relatively" generic modules for use by other businesses or others.\n\nObviously, the larger the number of general-purpose modules, the fewer modules that need to be customized and the lower the development cost.\n\n## Features\n\n\n- 🛠 High scalability\n\n"Everything" can be a module, from a beautiful button, a simple arithmetic function, to a complete ERP system, can be used as a module in FreeEIS. Flexible module splitting, zero coupling between modules, module plug and play. At the same time, considering the extensibility of the module itself, the module can be developed as a "plug-in" for another module.\n\n- 🎯 Focus on business logic\n\nThe FreeEIS kernel prefabricates functions that are not related to business logic, so that developers only need to consider the business logic inside the module, such as module loading, reference dependencies, multi-language support, multi-style support, data model generation, permission management and control, route generation, mock function, etc. have been built into the FreeEIS kernel, and there is no need to consider it during module development. In particular, parts such as data model generation, permission management and control, which usually consume a lot of developers\' energy, have also been stripped and decoupled, greatly improving development efficiency.\n\n- 🚀 Quick integration\n\nAll functions in FreeEIS are split into large and small modules, when it needs to be integrated into a complete system, only need to configure the required modules, or put the module code (directory) in a unified location, FreeEIS kernel will automatically load all required modules, and integrate into a complete system. This makes system-level assembly more flexible and can be integrated into complete systems of completely different sizes and functions as quickly as needed.\n\n- 🍹 Do not change development habits\n\nFreeEIS tries its best to achieve less packaging and no SDK, so as to avoid changing existing development habits. A scaffolding project + a simple set of specifications enables rapid system development.\n\n- 🚪 Code security\n\nIn some scenarios, we don\'t want all developers to get a lot or even all the code of the functional module before they can run and debug their own functional module. FreeEIS is designed so that developers only need to access the code base of their own functional modules, which can ensure code security without affecting development.\n\n\n## Usage\n\n### Prerequisites\n\nIn the current version, the front-end uses the following technologies or frameworks, which you need to have knowledge of or even experience with:\n - [VUE3] (https://vuejs.org/) is the basis for our entire front-end section.\n - [Quasar Framework] (https://quasar.dev/) is a VUE-based framework with a variety of features, such as rich components, support for Material Design, support for cross-platform, and so on. However, FreeEIS does not prohibit the use of other component libraries, you can still choose according to your preference, we just use the scaffolding and cross-platform support of the Quasar Framework, and even you can use FreeEIS in other VUE projects that have nothing to do with the Quasar Framework.\n\nIn the current version, the backend uses the following technologies or frameworks, which you need to have knowledge of or even experience:\n - [NodeJS] (https://nodejs.org/) is the foundation!\n - [ExpressJS] (http://expressjs.com/) is the foundation of 😉 the foundation.\n - [MongoDB] (https://www.mongodb.com/), [Mongoose] (http://www.mongoosejs.net/), The database operation modules that have been implemented so far are based on Mongoose, but we expect to add more database support in the future.\n - [Redis] (https://redis.io/), it is recommended to use Redis\' docker image deployment.\n\n### Frontend\n\n```sh\n# Install front-end scaffolding\n\n$ git clone https://github.com/freeeis/free-fe-starter-kit.git fe\n\n# Install dependent packages\n$ cd fe\n$ yarn install\n\n# Run\n$ yarn start\n\n```\n\n### Backend\n\nBefore using the backend, install MongoDB and Redis, or you can use a remotely deployed instance, whose addresses and ports are configured with the relevant built-in modules of FreeEIS. In addition, Redis is not required, if you cannot connect to Redis, FreeEIS will use [memory-cache](https://github.com/ptarjan/node-cache#readme) as a cache, which will not affect development or running.\n\n```sh\n# Install back-end scaffolding\n\n$ git clone https://github.com/freeeis/free-be-starter-kit.git be\n\n# Install dependent packages\n$ cd be\n$ yarn install\n\n# Create files to store confidential data (can also be created manually)\n$ touch global.js\n\n# Run\n$ yarn start\n\n```\n\n### Access the system\n\nAfter successfully running the front-end and back-end projects, access the system via the link [http://localhost:8080](http://localhost:8080/). You can also modify the configuration so that the front-end automatically opens the page from the browser after running.\n\n## Built-in function modules\n\nWe hope to simplify the work of developers by providing some built-in functional modules, such as account management, permission control, which are required in any system, and we have made modules that can be directly referenced. Below is a list of the built-in feature modules we currently offer, as well as their features. Of course, according to our purpose, we do not force you to use any of the built-in modules, you can customize and develop all the required modules according to your needs, but just use the specifications of FreeEIS and use her to assemble the system. And we encourage you to do so, because we believe that there are many more professional developers in any field than we are, and we want more people to develop more and more powerful functional modules for others to use.\n\n\n| Module | Front-end module | Backend module | Features | Description|\n| :------- |------- |------- | ----|----: |\n| Core | [free-fe-core](https://github.com/freeeis/free-fe-core) | [free-be-core](https://github.com/freeeis/free-be-core) | Load other modules | added in scaffolding by default |\n| Basic features | [free-fe-core-modules](https://github.com/freeeis/free-fe-core-modules) | [free-be-core-modules](https://github.com/freeeis/free-be-core-modules)| Data dictionary, log, menu management, system configuration, <br>error code management, cache management, day of mourning, <br>file handling, data verification methods, <br>multi-language support, multi-skin support, and more | Added in scaffolding by default|\n| Account Management | [free-fe-account](https://github.com/freeeis/free-fe-account) | [free-be-account](https://github.com/freeeis/free-be-account) | Account management, organizational structure management, authority <br>management, Role management, permission control| Added in scaffolding by default\n| Database | / | [free-be-mongodb](https://github.com/freeeis/free-be-mongodb) | Database Operations | Added in scaffolding | by default\n| Demo Module | [free-fe-demo](https://github.com/freeeis/free-fe-demo) | [free-be-demo](https://github.com/freeeis/free-be-demo) | Demonstrate the structure and usage of a module | Added in scaffolding by default\n\n\n## Contact us\n\nScan the code to add WeChat to join the communication group\n\n<img width="120" alt="" style="margin-left:24px" src="https://user-images.githubusercontent.com/33030594/227093642-b38b7871-16eb-48b6-b96a-191433dc55c2.png">\n\n\n## Contribute\n\nFreeEIS虽然已经在多个大型项目中得到了验证，但做为开源项目她依然处于比较早期的阶段，需要各位大牛的帮助一起成长。我们欢迎任何建议或意见或贡献，小到一个字的修改，大到架构的调整建议。我们感谢您的任何捐赠、PR、[Issue](https://github.com/freeeis/community/issues)等等，有任何相关问题都可以发邮件给我们：【[freeeis@xixineis.com](mailto:freeeis@xixineis.com)】。感谢🙏🙏！！\n\nAlthough FreeEIS has been verified in many large-scale projects, it is still in its early stages as an open source project and needs the help from all you guys. We welcome any suggestions or comments or contributions, from one-word changes to structural adjustments. We appreciate any donations, PRs, [Issue](https://github.com/freeeis/community/issues) etc., and if you have any related questions, please email us: [[freeeis@xixineis.com] (mailto:freeeis@xixineis.com)]. Thanks 🙏🙏!!\n',r=o},56682:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});var o=t(56395),r=t(40019);const s={"en-us":o["default"],"zh-cn":r["default"]}},64037:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>u});var o=t(59835);const r="## 规范\n\nFreeEIS中，任何的功能都应该被实现为独立的模块，而这些独立的模块通常都是可以独立运行的，模块开发人员可以自行开发调试，而不需要依赖于其他部分。而负责集成的人员，只需要将各功能模块关联到一个统一的集成环境中，根据需要对每个功能模块进行配置，即可运行起整套系统。\n\n但FreeEIS也实现了模块对模块的扩展功能，以满足“模块插件”的需求，这种情况下，新开发的“插件”模块需要在被扩展的模块存在的情况下进行。在此种情况下，模块不能真的完全独立开发和运行，但考虑到新模块是某现有模块的扩展插件，此两个模块可以做为一个整体考虑的情况下，我们依然可以说他是独立开发和运行的。\n\n这是FreeEIS开发的第一核心思想。\n\n## 前提条件\n\nFreeEIS后端基于ExpressJS开发而来，所以你需要对ExpressJS有一定的了解，而ExpressJS是一个基于NodeJS的后端框架，包括路由、中间件等特性，所以你也需要对NodeJS有更深的了解。当前版本中，我们使用了ExpressJS 4.x。\n",s='## 脚手架\n\nFreeEIS后端开发通过FreeEIS脚手架工程开始。脚手架工程做为模块开发的基础，同时也是系统集成的基础，任何模块的运行都需要通过脚手架工程来完成。\n\n### 运行\n\n\n```sh\n# 安装后端脚手架\n$ git clone https://github.com/freeeis/free-be-starter-kit.git be\n\n# 安装依赖包\n$ cd be\n$ yarn install\n\n# 运行\n$ yarn start\n```\n\n此时可以通过浏览器访问接口`http://localhost:8000/api/nothing`将得到返回结果`{"data":{},"msg":"OK"}`，说明你的后端脚手架已经运行成功。\n\n另需要注意的是，在脚手架中，默认加入了一些内置模块，在后面的章节开始介绍实际的开发内容前会有详细的说明如何禁用内置模块，以从一个更加“干净”的环境开始创建自己的模块。\n\n### 目录结构\n\nFreeEIS脚手架目录结构如下：\n\n```\n--- app\n  -- bin\n  -- config\n    -- config.default.js\n    -- config.development.js\n    -- config.production.js\n    -- config.test.js\n  -- modules\n  -- test\n  -- utils\n  -- app.js\n  -- global.js\n\n```\n\n在这个目录结构中：\n  - `bin`，FreeEIS运行不同环境的入口。\n  - `config`，配置文件存放位置，用于配置FreeEIS中不同运行环境下的全局配置信息，也可以用以覆盖各模块的默认配置以达到定制使用模块的目标。默认我们放入了三个环境的配置文件，development，test和production，但你完全可以根据自己的需要扩充。\n    - `config.default.js`，默认配置，所有环境公用的配置信息，或默认的配置信息。会被下面特定运行环境的配置信息覆盖（或扩展）。\n    - `config.development.js`，开发环境中的配置信息。\n    - `config.production.js`，生产环境中的配置信息。\n    - `config.test.js`，测试环境中的配置信息。\n  - `modules`，FreeEIS模块存放目录，模块可以直接保存在此目录中，也可以使用git submodule等功能引用。\n  - `test`，测试代码目录。\n  - `utils`，全局工具方法存放目录。我们并不建议使用全局工具，因为那样将导致某些模块不能独立开发，而必须要依赖于拥有此工具的工程，但在某些特殊场景下提取公用工具是必要的，所以我们保留了此能力。\n  - `app.js`，代码入口，调用FreeEIS内核模块并载入和运行所需要的其他模块。\n  - `global.js`，全局密钥存放文件，此文件中保存系统中各模块需要的密钥等机密信息，不应该上传到代码仓库！！部署时，应该通过手动写入服务器等方法确保机密信息的安全。\n\n\n### 可以做的事情\n\n当脚手架工程成功运行后，我们已经可以开始实际的开发工作，我们可以做这些事情：\n\n - 根据需要修改`config`目录中相应环境的配置信息。\n - 在`modules`目录中添加新的功能模块。\n - 在`utils`目录中添加全局工具。\n\n 但这些工作在通常的开发过程中不一定需要全都做，当我们考虑不同开发人员角色的时候，可以做如下拆分：\n\n#### 模块开发人员\n\n模块开发人员通常只需要：\n\n - 在`modules`目录中添加新的功能模块。\n\n#### 系统集成人员\n\n系统集成人员通常需要：\n\n - 根据需要修改`config`目录中相应环境的配置信息。\n - 在`modules`目录中引入需要的功能模块。\n\n\n我们将分别做详细的介绍。\n\n',i="## 模块开发\n\n### 修改启动模块\n\n前面提到过，模块开发人员可能需要禁用内置模块来得到一个“干净”的环境来创建自己的模块。要禁用内置模块，或修改需要启动的模块，可以通过修改`config/config.development.js`来实现，如下：\n\n```javascript\nexport default {\n  modules: [\n    // {\n    //     name: 'db',\n    //     path: 'free-be-mongodb',\n    // },\n    // 'account',\n    // 'core-modules',\n    // 'demo',\n  ],\n  ...\n};\n\n```\n\n这里的`modules`就是需要启动的模块列表，脚手架默认启动`mongodb`、`account`、`core-modules`、`demo`模块，这里我们把他们从`modules`列表中移除即可将其禁用。这里对数据库模块的引用是对象的形式，关于这种方式的使用后续会有详细的介绍。\n\n\n### 创建模块\n\n接下来我们创建一个新模块，在`modules`目录中添加一个子目录`my-first-module`，其目录结构如下：\n\n```\n-- src\n  -- modules\n    -- my-first-module\n      -- index.js\n      -- routers\n        -- index.js\n        -- route.js\n```\n\n其中`index.js`是我们新模块的入口文件，它的内容如下：\n\n```javascript\n// my-first-module/index.js\nmodule.exports = {};\n```\n\n目录routers为接口代码目录，FreeEIS会自动从这个目录里按层级加载接口定义。其中`index.js`是`routers`目录中每个目录层级都需要有的正对当前接口层级的一些定义内容，后面详细说明，这里先返回空对象。\n\n```javascript\n// my-first-module/routers/index.js\nmodule.exports = {};\n```\n\n而`route.js`，是接口定义代码文件。FreeEIS会将这些目录中除`index.js`以外的`js`文件全部做为接口定义代码文件加载，所以我们可以将同一层级下的接口按需要拆分到多个代码文件中，名称按需定义即可。这里我们只有一个`route.js`文件，返回了`ExpressJS`的`router`对象，但该对象中并没有定义接口。\n\n```javascript\n// my-first-module/routers/route.js\n\nconst path = require(\"path\");\nconst express = require(path.resolve('./') + \"/node_modules/express\");\nconst router = express.Router();\n\n\nmodule.exports = router;\n```\n\n这时我们就已经有了一个新的模块，而要让它被启动，我还需要将它添加到`config.development.js`的`modules`中。\n\n```javascript\n\nexport default {\n  modules: [\n    'my-first-module'\n  ],\n};\n\n```\n\n此时，我们的模块是空的，没有任何接口。接下来，我们创建接口，在`route.js`中添加接口定义：\n\n```javascript\n// modules/my-first-module/routers/route.js\n\nconst path = require(\"path\");\nconst express = require(path.resolve('./') + \"/node_modules/express\");\nconst router = express.Router();\n\nrouter.get('', (req, res, next) => {\n    res.addData(`hello world`);\n\n    return next();\n})\n\nmodule.exports = router;\n```\n\n到这里，我们的模块中有了一个接口，但是我们却不知道怎么调用他。FreeEIS允许后端模块不暴露接口，所以在需要暴露接口的模块中，我们需要明确告诉FreeEIS。我们修改模块入口文件如下：\n\n```javascript\n// my-first-module/index.js\n\nmodule.exports = {\n    config: {\n        asRouteService: true, // 告诉FreeEIS，本模块将提供接口路由服务\n        routeRoot: 'mymodule',// 当模块提供接口路由服务时，我们需要告诉FreeEIS，本模块的接口根路径是什么。\n    },\n}\n```\n\n重启后端服务，然后通过浏览器访问`http://localhost:8000/api/mymodule`，将会得到`{\"data\":\"hello world\",\"msg\":\"OK\"}`。\n\n这里需要注意几天：\n\n - FreeEIS自动从模块中的`routers`目录加载带有层级结构的接口定义，所以不需要额外做其他工作，就可以自动暴露其中定义的接口。\n - FreeEIS自动在所有的接口前面添加`/api`，做为后端接口的前缀，这个前缀可以通过修改`config/config.default.js`中的`baseUrl`来控制。这个前缀的另一个好处是，当我们有多个版本的后端服务，或在多个服务合作提供后端支持的时候，可以通过定义不同的前缀来区分不同的接口集合。\n - 需要暴露接口路由的模块，需要显式配置相应配置项，否则模块中的接口将不会被加载。\n\n\n### 动态数据\n\n到这里我们已经成功定义了一个新的FreeEIS后端模块，并且暴露出一个新的接口，返回了一些数据。但在更常见的情况下，接口需要返回的内容是可变的，这有两种情况：一是某些内容通过配置而来；二是某些内容通过数据库而来。我们分别介绍。\n\n#### 模块配置\n\n在我们的这个实例模块中，假设我们需要hello的目标不是固定的'world'， 而是需要根据情况而定，那么我们可以在模块中添加相应的配置参数，使得这部分内容可变。\n\n我们在模块入口文件添加如下配置定义（这种定义可以被剥离出来放在任何其他文件中）：\n\n```javascript\n// my-first-module/index.js\n\nmodule.exports = {\n    config: {\n        asRouteService: true,\n        routeRoot: 'mymodule',\n\n        greetingTo: 'world',\n    },\n}\n```\n\n我们在接口代码中引用这个配置参数：\n\n\n```javascript\n// modules/my-first-module/routers/route.js\n\nconst path = require(\"path\");\nconst express = require(path.resolve('./') + \"/node_modules/express\");\nconst router = express.Router();\n\nrouter.get('', (req, res, next) => {\n    res.addData(`hello ${router.mdl.config.greetingTo}`);\n\n    return next();\n})\n\nmodule.exports = router;\n```\n\n这里，我们通过`router.mdl.config.greetingTo`来访问上面定义的配置参数。FreeEIS自动将当前模块的实例改在到了`router.mdl`中，所以我们可以访问当前模块入口文件中定义的所有信息。\n\n重启后端服务，然后通过浏览器访问`http://localhost:8000/api/mymodule`，依然会得到`{\"data\":\"hello world\",\"msg\":\"OK\"}`，但这里的`world`是动态的内容。\n\n#### 数据库\n\n另一种情况是，数据来自数据库。如果我们的模块需要数据库支持，那么我们需要先定义所需要的数据模型，这在FreeEIS后端中非常简单，只需要在模块的入口文件中像这样定义：\n\n\n```javascript\n// my-first-module/index.js\n\nmodule.exports = {\n    config: {\n        asRouteService: true,\n        routeRoot: 'mymodule',\n\n        greetingTo: 'world',\n    },\n    data: {\n        world: {\n            Name: { type: 'String', required: true },\n            Size: { type: 'String', default: 'large', },\n        },\n    },\n}\n```\n\n这上面的代码中，我们在当前模块中添加了一个叫`world`的数据模型，其中包含两个字段，`Name`和`Size`。这样，FreeEIS即可自动为我们生成对应的数据模型。接下来，我们从我们的接口代码中调用此数据模型：\n\n\n\n```javascript\n// my-first-module/routers/route.js\n\n...\nrouter.get('/', async (req, res, next) => {\n    const worldsCount = await res.app.models.world.countDocuments({});\n    res.addData(`hello ${worldsCount} worlds`);\n\n    return next();\n})\n...\n\n```\n\n上面的代码中，我们通过`res.app.models.world`访问到我们新定义的数据模型，并调用`countDocuments`方法来返回数据条数。\n\n\n但这时重新启动服务，并不能得到期望的结果，是因为FreeEIS中对数据库的支持也做为独立的模块存在，默认FreeEIS提供了内置的`MongoDB`数据库支持，需要通过将其加入到`config/config.development.js`的`modules`列表中来启用：\n\n\n```javascript\nexport default {\n  modules: [\n    {\n        name: 'db',\n        path: 'free-be-mongodb',\n    },\n    'my-first-module'\n  ],\n};\n\n```\n\n在这里，我们需要注意`modules`列表中各项的顺序，因为我们的`my-first-module`需要使用`mongodb`模块中的能力，所以需要将`mongodb`模块放在前面，以优先加载。这可以通过另外一种方式来达到我们的目的，就是将`mongodb`模块添加到`my-first-module`的依赖列表中：\n\n```javascript\n  ...\n  config: {\n      asRouteService: true,\n      routeRoot: 'mymodule',\n      dependencies: [\n          'db'\n      ],\n\n      greetingTo: 'world',\n  },\n\n  ...\n```\n\n\n这样FreeEIS在加载模块列表的时候，即便`db`模块在`my-first-module`模块的后面，也会先加载`db`以确保按正确的依赖关系加载所有的模块。\n\n这里我们使用的`db`模块是`free-be-mongodb`，但现实中，我们可能使用其他的数据库，那么我们就需要引入另一个数据库模块，比如`freeeis-mysql`，那么我们引入此数据库模块的方式应该为：\n\n\n```javascript\n\nexport default {\n  modules: [\n    {\n        name: 'db',\n        path: 'freeeis-mysql',\n    },\n    'my-first-module'\n  ],\n};\n\n```\n\n这就是为什么我们允许在模块列表中使用对象的形式，因为像`db`这类比较通用的模块，可能有多种实现方式，这使得像`my-first-module`这样的模块，只需要声明他依赖于`db`模块，而不需要关心系统集成者使用的是哪一个数据库模块。当然，这要求所有的数据库模块都暴露了相同的接口或方法，这在讲到内置模块中的数据库模块时会有详细的讲解。\n\n\n### 模块使用者覆盖模块配置项\n\n回到我们的接口定义文件中，将其改为：\n\n\n```javascript\n// my-first-module/routers/route.js\n\n...\nrouter.get('/', (req, res, next) => {\n    res.addData(`hello ${router.mdl.config.greetingTo}`);\n\n    return next();\n})\n\nrouter.get('/count', async (req, res, next) => {\n    const worldsCount = await res.app.models.world.countDocuments({});\n    res.addData(`hello ${worldsCount} worlds`);\n\n    return next();\n})\n\n...\n```\n\n这里我们在第一个接口中返回了带有`greetingTo`的字符串。这时，假设我们的`my-first-module`已经开发完成，系统集成者或其他希望使用此模块的开发者，可能需要对我们定义的`greetingTo`配置项进行更多的控制，他可以这样做：\n\n```javascript\n// config/config.development.js\n\nexport default {\n  modules: [\n    'my-first-module',\n    {\n        name: 'db',\n        path: 'free-be-mongodb',\n    },\n  ],\n\n  'my-first-module': {\n    greetingTo: 'FreeEIS'\n  },\n};\n\n```\n\n这时，重启后端服务，然后通过浏览器访问`http://localhost:8000/api/mymodule`，会得到`{\"data\":\"hello FreeEIS\",\"msg\":\"OK\"}`。这给系统集成者或模块使用者了充分的自由来控制模块的可变参数。\n\n\n### 多语言支持\n\nFreeEIS后端也支持多语言，以应对某些固定字符串从后端返回时的翻译问题。\n\n继续使用上面我们创建的模块，假设我们需要对`hello`这个词进行中文和英文的支持，我们需要在模块入口文件中添加相应翻译字典的定义：\n\n\n```javascript\n  ...\n  config: {\n      asRouteService: true,\n      routeRoot: 'mymodule',\n      dependencies: [\n          'db'\n      ],\n\n      greetingTo: 'world',\n  },\n  i18n: {\n      'en-us': {\n          hello: 'hi',\n      },\n      'zh-cn': {\n          hello: '你好',\n      },\n  },\n\n  ...\n\n```\n\n这里的`i18n`显然也可以剥离出来单独存放并在这里引入。\n\n这时，重启后端服务，然后通过浏览器访问`http://localhost:8000/api/mymodule`，会得到`{\"data\":\"你好 FreeEIS\",\"msg\":\"OK\"}`。FreeEIS后端也会在不能确定当前翻译语言时，使用中文做为默认语言。\n\n我们可以通过修改`app.ctx.locale`，或者给`t()`函数传入第二个参数，来控制翻译语言：\n\n\n```javascript\n// my-first-module/routers/route.js\n\n...\nrouter.get('/', (req, res, next) => {\n    res.app.ctx.locale = 'en-us';\n\n    res.addData(`${router.mdl.t('hello', 'en-us')} ${router.mdl.config.greetingTo}`);\n\n    return next();\n})\n\n...\n```\n\n但这里，只是示意性的，更常见的方式是通过前端传入的当前语言，来决定使用哪种语言进行翻译。比如：\n\n\n```javascript\n// my-first-module/routers/route.js\n\n...\nrouter.get('/', (req, res, next) => {\n    const locale = req.query.locale;\n\n    res.addData(`${router.mdl.t('hello', locale)} ${router.mdl.config.greetingTo}`);\n\n    return next();\n})\n\n...\n```\n\n当我们有更多的语言需要支持时，只要在i18n中添加相应的翻译字典即可。比如，我们添加另一种语言，如下：\n\n\n```javascript\n  ...\n  i18n: {\n      'en-us': {\n          hello: 'hi',\n      },\n      'zh-cn': {\n          hello: '你好',\n      },\n      '火星语': {\n          hello: '🚀🚀🚀',\n      },\n  },\n  ...\n```\n\n\n我们直接使用`火星语`对`hello`进行翻译：\n\n\n```javascript\n// my-first-module/routers/route.js\n\n...\nrouter.get('/', (req, res, next) => {\n    res.addData(`${router.mdl.t('hello', '火星语')} ${router.mdl.config.greetingTo}`);\n\n    return next();\n})\n\n...\n```\n\n\n这时，重启后端服务，然后通过浏览器访问`http://localhost:8000/api/mymodule`，会得到`{\"data\":\"🚀🚀🚀 FreeEIS\",\"msg\":\"OK\"}`。\n",a="\n## 系统集成\n\n系统集成开发者与模块开发者的目标不同，他们需要按需求把各功能模块集成到一起，使他们可以一起工作。\n\n功能模块有三种方式引入：\n\n - 公开发布的模块可以通过`yarn add`添加到package.json中。\n - 私有模块可以直接将模块放在`modules`目录中。\n - 远程开发人员开发的放在独立代码库中的模块可以通过`git submodule`添加到`modules`目录中。\n\n比如，我们添加了三个模块：\n\n - free-be-core-modules，已经公开发布的模块。\n - my-first-module，我们自己开发的直接入在modules目录中的模块。\n - my-second-module，另一名开发人员开发的放在独立代码仓库中的模块。\n\n引入这三个模块后，我们的集成工程的目录结构如下：\n\n```\n-- app\n  -- node_modules\n    -- free-be-core-modules，通过`yarn add free-fe-core-modules`添加。（脚手架中已经添加）\n  -- modules\n    -- my-first-module，这是一个本地目录，模块代码就在这里。\n    -- my-second-module，这是通过`git submodule`添加的远程库。\n```\n\n### 启用需要的模块\n\n引入的模块默认不会被加载运行，如果需要加载运行他们，需要将他们添加到config的modules中，上面提到的三种方式添加的模块都是以同样的方式启动。像这样：\n\n```javascript\n// config/config.development.js\n\nexport default {\n  modules: [\n    {\n        name: 'db',\n        path: 'free-be-mongodb',\n    },\n    'core-modules',\n    'my-first-module',\n    'my-second-module',\n  ],\n\n  'my-first-module': {\n    greetingTo: '中国'\n  },\n};\n\n```\n\n这里你可能会注意到，我们添加了一个名为`core-modules`的模块，是因为名字以`free-be-`开头的模块在引入时，可以省略这个前缀。但是我们不建议你使用这样的命名方法来命名你自己的模块，因为他们是为FreeEIS内置模块预留的。\n\n",l="## 内置模块介绍\n\n```文档更新中………```\n",d="## 高阶功能\n\n```文档更新中………```\n",u={c:`${r}${s}${i}${a}${l}${d}`,preComponents:[(0,o.h)("h1",{class:"text-center q-mb-xl"},["FreeEIS 后端开发"]),(0,o.h)("p",{align:"center"},[(0,o.h)("img",{src:"https://user-images.githubusercontent.com/33030594/227073920-03ed137f-c4f7-4ed7-ae05-d781dd1991f7.png",alt:"FreeEIS",width:"250"})])]}},72784:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>p});var o=t(60499),r=t(59835),s=t(97052),i=t(41694),a=t(70335),l=t(38346);const d="## 规范\n\nFreeEIS中，任何的功能都应该被实现为独立的模块，而这些独立的模块通常都是可以独立运行的，模块开发人员可以自行开发调试，而不需要依赖于其他部分。而负责集成的人员，只需要将各功能模块关联到一个统一的集成环境中，根据需要对每个功能模块进行配置，即可运行起整套系统。\n\n但FreeEIS也实现了模块对模块的扩展功能，以满足“模块插件”的需求，这种情况下，新开发的“插件”模块需要在被扩展的模块存在的情况下进行。在此种情况下，模块不能真的完全独立开发和运行，但考虑到新模块是某现有模块的扩展插件，此两个模块可以做为一个整体考虑的情况下，我们依然可以说他是独立开发和运行的。\n\n这是FreeEIS开发的第一核心思想。\n\n## 前提条件\n\nFreeEIS前端基于Quasar Framework开发而来，所以你需要对Quasar Framework有一定的了解，而Quasar Framework是一个基于VUE的前端框架，包括组件库和跨平台支持等特性，所以你也需要对VUE有更深的了解。当前版本中，我们使用了Quasar Framework 2.x，其基于VUE3.x。\n\n为了使用FreeEIS开发应用，你还可能需要了解Webpack和NodeJS本身的一些内容。但是因为VUE和Quasar Framework都进一步做了封装，所以在一般情况下，你不需要意识到他们的存在。\n",u="## 脚手架\n\nFreeEIS前端开发通过FreeEIS脚手架工程开始。FreeEIS前端脚手架工程基于Quasar Framework的脚手架工程，只是把FreeEIS内核模块嵌入，进而实现了FreeEIS模块的加载和运行工作。\n\n脚手架工程做为模块开发的基础，同时也是系统集成的基础，任何模块的运行都需要通过脚手架工程来完成。\n\n### 运行\n\n\n```sh\n# 安装前端脚手架\n$ git clone https://github.com/freeeis/free-fe-starter-kit.git fe\n\n# 安装依赖包\n$ cd fe\n$ yarn install\n\n# 运行\n$ yarn start\n```\n\n此时可以通过`http://localhost:8080`来查看系统页面，但请注意终端输出，在当端口8080已经被占用时，可能会使用8081等其他端口。\n\n另需要注意的是，在脚手架中，默认加入了一些内置模块，有些内置模块需要相应后端模块的支持，而由于一些历史原因在这些内置模块开发的时候并没有加入足够的Mock信息，所以单独运行前端脚手架可能会在某些接口调用时报错。我们会逐步添加mock内容以使这些内置模块也可以脱离后端运行。在后面的章节开始介绍实际的开发内容前会有详细的说明如何禁用内置模块，以从一个更加“干净”的环境开始创建自己的模块。\n\n### 目录结构\n\nFreeEIS脚手架目录结构如下：\n\n```\n--- app\n   -- ...\n   -- public\n   -- src\n      App.vue\n      Error404.vue\n      -- boot\n      -- config\n          -- config.default.js\n          -- config.development.js\n          -- config.production.js\n          -- config.test.js\n          index.js\n      -- css\n          app.scss\n          quasar.variables.scss\n      -- modules\n      -- router\n      -- stores\n      -- utils\n      ...\n  ...\n\n```\n\n在这个目录结构中，有很多是Quasar Framework所定义的，请参考[官方文档](https://quasar.dev)，我们只介绍在开发FreeEIS应用时直接相关的部分：\n- `public`，此目录为静态资源目录，图片图标或其他静态资源放在这里，这个目录中的内容会在编译后直接拷贝到输出目录中。但基于我们的开发规范，我们应该尽力避免使用全局公用的资源，而应该放置在每个模块中，但在某些特殊场景下，我们依然可以这么做。\n- `src`，这里是开发代码的存放目录。\n  - `App.vue`，这是入口vue文件，通常不需要修改。\n  - `Error404.vue`，这是当找不到指定页面报404时，显示的页面。\n  - `boot`，这里是Quasar Framework的boot文件存放位置，关于boot文件的详细信息，请参见Quasar Framework。我们在其中加入了必要的文件以支撑FreeEIS的启动。\n  - `config`，配置文件存放位置，用于配置FreeEIS中不同运行环境下的全局配置信息，也可以用以覆盖各模块的默认配置以达到定制使用模块的目标。默认我们放入了三个环境的配置文件，development，test和production，但你完全可以根据自己的需要扩充。\n    - `config.default.js`，默认配置，所有环境公用的配置信息，或默认的配置信息。会被下面特定运行环境的配置信息覆盖（或扩展）。\n    - `config.development.js`，开发环境中的配置信息。\n    - `config.production.js`，生产环境中的配置信息。\n    - `config.test.js`，测试环境中的配置信息。\n    - `index.js`，配置信息入口，此文件会自动加载当前目录中所有配置环境的配置文件，并根据当前运行环境使用相应配置。\n  - `css`，全局样式文件保存的位置。我们建议使用FreeEIS的样式皮肤模块，而尽量减少在此处定义全局样式。但基于显而易见的原因，我们保留这里的功能。样式皮肤模块，是一类特殊的模块，专门定义不同的样式皮肤，后续会有详细的介绍。\n    - `app.scss`，全局样式入口。\n    - `quasar.variables.scss`，全局样式变量定义文件，全局样式变量可以从整体上规范模块样式的设计。\n  - `modules`，FreeEIS模块存放目录，模块可以直接保存在此目录中，也可以使用git submodule等功能引用。\n  - `router`，路由入口。\n  - `stores`，状态管理入口，当前版本中我们使用Pinia。\n  - `utils`，全局工具方法存放目录。我们并不建议使用全局工具，因为那样将导致某些模块不能独立开发，而必须要依赖于拥有此工具的工程，但在某些特殊场景下提取公用工具是必要的，所以我们保留了此能力。\n\n### 可以做的事情\n\n当脚手架工程成功运行后，我们已经可以开始实际的开发工作，我们可以做这些事情：\n\n - 在`public`目录中添加全局静态资源。\n - 根据需要修改`config`目录中相应环境的配置信息。\n - 在`modules`目录中添加新的功能模块。\n - 在`css`目录中修改全局样式。\n - 在`utils`目录中添加全局工具。\n\n 但这些工作在通常的开发过程中不一定需要全都做，当我们考虑不同开发人员角色的时候，可以做如下拆分：\n\n#### 模块开发人员\n\n模块开发人员通常只需要：\n\n - 在`modules`目录中添加新的功能模块。\n\n#### 系统集成人员\n\n系统集成人员通常需要：\n\n - 根据需要修改`config`目录中相应环境的配置信息。\n - 在`modules`目录中引入需要的功能模块。\n\n\n我们将分别做详细的介绍。\n\n",c="## 模块开发\n\n### 修改启动模块\n\n前面提到过，模块开发人员可能需要禁用内置模块来得到一个“干净”的环境来创建自己的模块。要禁用内置模块，或修改需要启动的模块，可以通过修改`src/config/config.development.js`来实现，如下：\n\n```javascript\nexport default {\n  modules: [\n    // 'main'\n  ],\n};\n\n```\n\n这里的`modules`就是需要启动的模块列表，脚手架默认启动`main`模块，他是一个示意性的“封装模块”，用来更精细地控制所启动的其他模块。关于“封装模块”后面会有详细介绍，这里我们只需要把它从`modules`列表中移除即可将其禁用。\n\n\n### 创建模块\n\n接下来我们创建一个新模块，在`modules`目录中添加一个子目录`my-first-module`，其目录结构如下：\n\n```\n-- src\n  -- modules\n    -- my-first-module\n      -- index.js\n```\n\n其中`index.js`是我们新模块的入口文件，它的内容如下：\n\n```javascript\nimport { defineComponent, h } from 'vue';\n\nexport default {\n  routers: [\n    {\n      path: '/',\n      component: defineComponent({\n        name: 'MyComp',\n        setup() {\n          return ()  => h('div', {\n            class: 'absolute-center text-h3'\n          }, ['hello world']);\n        },\n      }),\n    },\n  ],\n};\n```\n\n这时我们就已经有了一个新的模块，而要让它被启动，我还需要将它添加到`config.development.js`的`modules`中。\n\n```javascript\n\nexport default {\n  modules: [\n    'my-first-module'\n  ],\n};\n\n```\n\n此时再回到浏览器中访问`http://localhost:8080`(或根据终端提示访问相应的端口)，你将看到`hello world`的文字，也就是我们模块中的第一个页面。\n\n这里，我将页面、路由、模块入口都写在了同一个文件当中，这可以运行，但从通常的最佳实践来说，我们应该把他们拆分开来。FreeEIS对于如何在模块内部拆分组织代码没有强制性规范，你可以根据自己的习惯来进行开发，只要在模块入口文件中指明需要暴露的路由即可。\n\n如下是我们进行拆分后的多个文件结构，其结果和我们上述单个文件的效果完全一致。\n\n```\n-- src\n  -- modules\n    -- my-first-module\n      -- index.js           # 这里依然是我们的模块入口文件\n      -- view               # 我们把“视图”文件放在这个目录中\n        -- hellowWorld.vue  # 这是我们的hello world页面\n      -- routes             # 我们把定义路由的部分放在这个目录中\n        -- index.js         # 这里面定义我们的路由\n```\n\n其中：\n\n```javascript\n// my-first-module/index.js\n\nimport routers from './routers';\n\nexport default {\n  routers,\n};\n\n```\n\n\n```vue\n\x3c!-- my-first-module/view/helloWorld.vue --\x3e\n\n<template>\n  <div class=\"absolute-center text-h3\">hello world</div>\n</template>\n\n<script>\nimport { defineComponent } from 'vue';\n\nexport default defineComponent({\n  name: 'HelloWorldPage',\n})\n<\/script>\n\n```\n\n\n```javascript\n/* my-first-module/routers/index.js */\n\nexport default [\n  {\n    path: '/',\n    component: () => import('../view/helloWorld.vue'),\n  }\n];\n\n```\n\n上面的拆分是示意性的，在复杂的模块中，需要根据实际情况来定，但核心思路是，FreeEIS不限制你的代码组织方式，只要确保在模块入口文件中可以找到相应的路由即可。\n\n\n### 模块配置\n\n组件或页面有`props`可以使我们的使用者对某些内容或逻辑加以控制，模块也同样需要这样的机制。\n\n在我们的这个实例模块中，假设我们需要hello的目标不是固定的'world'， 而是需要根据情况而定，那么我们可以在模块中添加相应的配置参数，使得这部分内容可变。\n\n我们在模块入口文件添加如下配置定义（但同样，这种定义可以被剥离出来放在任何其他文件中）：\n\n```javascript\n// my-first-module/index.js\n\nimport routers from './routers';\n\nexport default {\n  config: {\n    greetingTo: 'world',\n  },\n  routers,\n};\n```\n\n我们在组件代码中如下可以引用这个配置参数：\n\n```vue\n\x3c!-- my-first-module/view/helloWorld.vue --\x3e\n\n<template>\n  <div class=\"absolute-center text-h3\">hello {{greetingTo}}</div>\n</template>\n\n<script>\nimport { defineComponent, ref, getCurrentInstance, watchEffect } from 'vue';\n\nexport default defineComponent({\n  name: 'HelloWorldPage',\n  setup() {\n    const { proxy: { ctx } } = getCurrentInstance();\n    const greetingTo = ref('');\n\n    watchEffect(() => {\n      greetingTo.value = ctx.config['my-first-module'].greetingTo;\n    })\n\n    return {\n      greetingTo,\n    };\n  },\n})\n<\/script>\n\n```\n\n如果不使用组合式API，你可以通过`this.ctx`访问全局上下文，这个全局上下文中包括如下两个重要的内容：\n\n - `ctx.config`, 当前生效的全局配置信息，包括从`config`目录中根据当前环境加载的配置信息，也包括每个模块的配置信息，比如上面我们配置的`greetingTo`就可以通过`ctx.config['my-first-module'].greetingTo`来访问。\n - `ctx.modules`, 一个维护所有被加载的模块的列表，也就是你可以访问所有被加载的模块，这给使用或扩展现有模块带来了可能。\n\n### 模块使用者覆盖模块配置项\n\n假设我们的`my-first-module`已经开发完成，系统集成者或其他希望使用此模块的开发者，可能需要对我们定义的`greetingTo`配置项进行更多的控制，他可以这样做：\n\n```javascript\n// src/config/config.development.js\n\nexport default {\n  modules: [\n    'my-first-module',\n  ],\n\n  'my-first-module': {\n    greetingTo: '中国'\n  },\n};\n\n```\n\n这时，回到浏览器，我们可以看到，页面上已经显示`hello 中国`了。\n\n### 接口请求\n\n上面我们演示子如何创建新模块，并在模块中定义可变的配置项，但另一个常见情况是前端的某些数据来自后端接口。\n\n我们继续假设，在我们这个新模块中，greetingTo的内容来自一个叫`myModule/doSomething`的`POST`接口，我们修改我们的helloWorld组件如下：\n\n```vue\n\x3c!-- my-first-module/view/helloWorld.vue --\x3e\n\n<template>\n  <div class=\"absolute-center text-h3\">hello {{greetingTo}}</div>\n</template>\n\n<script>\nimport { defineComponent, ref, getCurrentInstance } from 'vue';\n\nexport default defineComponent({\n  name: 'HelloWorldPage',\n  setup() {\n    const { proxy:vm } = getCurrentInstance();\n    const greetingTo = ref('');\n\n    vm.postRequest('/myModule/doSomething').then((d) => {\n      greetingTo.value = d?.greeting || '中国';\n    })\n\n    return {\n      greetingTo,\n    };\n  },\n})\n<\/script>\n```\n\n此时页面会报错，因为此接口不存在。这就需要用到mock功能。我们在我们的模块入口文件中添加mock代码如下：\n\n```javascript\nimport routers from './routers';\n\nexport default {\n  config: {\n    greetingTo: 'world',\n  },\n  routers,\n  mock: (Mock) => {\n    Mock.mock('/myModule/doSomething', 'post', {\n      greeting: 'FreeEIS'\n    })\n  },\n};\n\n```\n\n这时再回到浏览器，可以看到页面上显示的是`hello FreeEIS`，这种情况下前端可以完全独立开发，而不需要后端的支持，当然，对于接口的定义双方要有一致的规范。如果一切正常，当后端接口开发完成后我们的页面即可以自然地过度到前后端的连接。\n\n### 接口请求方法\n\n上面我们看到，通过`vm.postRequest`我们调用了一个`post`类型的接口，其实在`vm`(也就是非组合式API情况下的`this`)中，我们有如下方法：\n\n - getRequest\n - postRequest\n - putRequest\n - deleteRequest\n\n他们分别调用相应方法的接口，都可以传入参数对象，但`get`调用时的参数对象会被解析成路径中的`query`字符串，而其他调用方法中的参数对象会以`body`的形式发送。比如：\n\n```javascript\nconst url = '/myModule/doSomething';\n\nvm.getRequest(url, { name: 'free' });\n// get /myModule/doSomething?name=free\n\nvm.postRequest(url, { name: 'free' })\n// post /myModule/doSomething ，body为： { name: 'free' }\n\nvm.putRequest(url, { name: 'free' });\n// put /myModule/doSomething ，body为： { name: 'free' }\n\nvm.deleteRequest(url, { name: 'free' });\n// delete /myModule/doSomething ，body为： { name: 'free' }\n```\n\n### 多语言支持\n\nFreeEIS中使用`vue-i18n`来提供多语言支持，但我们对其进行了封装，使得多语言支持更加简单。\n\n继续使用上面我们创建的模块，假设我们需要对`hello`这个词进行中文和英文的支持，我们需要创建一个18n目录，并在其中创建如下结构的文件：\n\n```\n-- src\n  -- modules\n    -- my-first-module\n      -- i18n\n        -- zh-cn\n          - index.js  # 中文翻译字典入口文件\n        -- en-us\n          - index.js  #  英文翻译字典入口文件\n```\n\n其中：\n\n```javascript\n// i18n/zh-cn/index.js\n\nexport default {\n  hello: '你好'\n}\n```\n\n\n```javascript\n// i18n/en-us/index.js\n\nexport default {\n  hello: 'hi'\n}\n```\n\n然后在`helloWorld.vue`中进行实时翻译：\n\n\n```vue\n\x3c!-- my-first-module/view/helloWorld.vue --\x3e\n\n<template>\n  <div class=\"absolute-center text-h3\">{{$t('hello')}} {{greetingTo}}</div>\n</template>\n\n<script>\nimport { defineComponent, ref, getCurrentInstance } from 'vue';\n\nexport default defineComponent({\n  name: 'HelloWorldPage',\n  setup() {\n    const { proxy:vm } = getCurrentInstance();\n    const greetingTo = ref('');\n\n    vm.postRequest('/myModule/doSomething').then((d) => {\n      greetingTo.value = d?.greeting || '中国';\n    })\n\n    return {\n      greetingTo,\n    };\n  },\n})\n<\/script>\n```\n\n此时，回到浏览器，看到的将是`你好 FreeEIS`。因为FreeEIS在不能判断当前需要使用的语言时默认使用中文。\n\n如下代码，我们添加了两个按钮，来切换当前语言：\n\n\n```vue\n\x3c!-- my-first-module/view/helloWorld.vue --\x3e\n\n<template>\n  <div class=\"absolute-center text-h3\">\n    {{$t('hello')}} {{greetingTo}}\n\n    <div class=\"row justify-center q-gutter-md q-mt-lg\">\n      <q-btn label=\"中文\" @click=\"changeLocaleTo('zh-cn')\"></q-btn>\n      <q-btn  label=\"English\" @click=\"changeLocaleTo('en-us')\"></q-btn>\n    </div>\n  </div>\n</template>\n\n<script>\nimport { defineComponent, ref, getCurrentInstance } from 'vue';\n\nexport default defineComponent({\n  name: 'HelloWorldPage',\n  setup() {\n    const { proxy:vm } = getCurrentInstance();\n    const greetingTo = ref('');\n\n    vm.postRequest('/myModule/doSomething').then((d) => {\n      greetingTo.value = d?.greeting || '中国';\n    })\n\n    return {\n      greetingTo,\n      changeLocaleTo: (l) => {\n        vm.$i18n.locale = l;\n      }\n    };\n  },\n})\n<\/script>\n\n```\n\n这时回到浏览器，可以通过两个按钮来切换语言。\n\n内置的`free-fe-core-modules`模块中有一些基础组件，比如`SelectLocales`组件，可以用来切换语言。我们通过添加此模块到配置中，来启动他：\n\n\n```javascript\n// config/config.development.js\n\nexport default {\n  modules: [\n    'core-modules',\n    'my-first-module',\n  ],\n\n  'my-first-module': {\n    greetingTo: '中国'\n  },\n};\n\n```\n\n\n再添加`SelectLocales`组件到`helloWorld`页面中，如下：\n\n```vue\n<template>\n  <div class=\"absolute-center text-h3\">\n    {{$t('hello')}} {{greetingTo}}\n\n    <div class=\"row justify-center q-gutter-md q-mt-lg\">\n      <select-locales></select-locales>\n    </div>\n  </div>\n</template>\n```\n\n这时回到浏览器，可以看到修改的效果。`SelectLocales`组件默认显示一个图标，当点击时出现下来菜单来选择语言，此组件更适合放在像顶部菜单栏之类的位置。\n\n当我们有更多的语言需要支持时，只要在i18n目录中添加相应的翻译字典，即可自动添加到下拉菜单中，实现实时翻译。比如，我们添加另一种语言，如下：\n\n\n```\n-- src\n  -- modules\n    -- my-first-module\n      -- i18n\n        -- zh-cn\n          - index.js  # 中文翻译字典入口文件\n        -- en-us\n          - index.js  # 英文翻译字典入口文件\n        -- 火星语\n          - index.js  # 火星语翻译字典入口文件\n```\n\n\n```javascript\n// i18n/火星语/index.js\n\nexport default {\n  hello: '🚀🚀🚀'\n}\n\n```\n\n此时回到浏览器中，点击切换语言按钮，可以看到`火星语`选项，选择`火星语`后页面内容变为`🚀🚀🚀 FreeEIS`。\n\n但，因为火星人不认识中文`火星语`这三个字，所以，虽然我们地球人对火星语的定义为`火星语`，就像我们定义中文为`zh-cn`一样，那么我们需要在页面上的下拉菜单中显示火星语的`火星语`三个字的意思，此时我们需要在全局配置菜单中的`locales`中添加此项语言，比如下：\n\n```javascript\n// config/config.default.js\n\n....\nlocales: [\n  ....,\n  {\n    name: '🚀🚀🚀',\n    locale: '火星语',\n  },\n],\n....\n\n```\n\n此时回到浏览器中，可以看到多语言选择的下拉框中自动出现了`🚀🚀🚀`的选项，这是火星人可以看懂的文字。\n\n注意，这些配置都可以根据运行环境不同而不同，运行环境中配置的相同项将会覆盖`config.default.js`中的项。\n\n",m="\n## 系统集成\n\n系统集成开发者与模块开发者的目标不同，他们需要按需求把各功能模块集成到一起，使他们可以一起工作。\n\n功能模块有三种方式引入：\n\n - 公开发布的模块可以通过`yarn add`添加到package.json中。\n - 私有模块可以直接将模块放在`modules`目录中。\n - 远程开发人员开发的放在独立代码库中的模块可以通过`git submodule`添加到`modules`目录中。\n\n比如，我们添加了三个模块：\n\n - free-fe-core-modules，已经公开发布的模块。\n - my-first-module，我们自己开发的直接入在modules目录中的模块。\n - my-second-module，另一名开发人员开发的放在独立代码仓库中的模块。\n\n引入这三个模块后，我们的集成工程的目录结构如下：\n\n```\n-- app\n  -- node_modules\n    -- free-fe-core-modules，通过`yarn add free-fe-core-modules`添加。（脚手架中已经添加）\n  -- src\n    -- modules\n      -- my-first-module，这是一个本地目录，模块代码就在这里。\n      -- my-second-module，这是通过`git submodule`添加的远程库。\n```\n\n### 启用需要的模块\n\n引入的模块默认不会被加载运行，如果需要加载运行他们，需要将他们添加到config的modules中，上面提到的三种方式添加的模块都是以同样的方式启动。像这样：\n\n```javascript\n// config/config.development.js\n\nexport default {\n  modules: [\n    'core-modules',\n    'my-first-module',\n    'my-second-module',\n  ],\n\n  'my-first-module': {\n    greetingTo: '中国'\n  },\n};\n\n```\n\n这里你可能会注意到，我们添加了一个名为`core-modules`的模块，是因为名字以`free-fe-`开头的模块在引入时，可以省略这个前缀。但是我们不建议你使用这样的命名方法来命名你自己的模块，因为他们是为FreeEIS内置模块预留的。\n\n\n### 封装模块\n\n前面我们提到了封装模块，他是一种特殊的模块。说他特殊是指他除了拥有普通模块的所有功能和特性外，还会使用一种特殊功能`路由引用`来重新编排所有需要暴露出来的路由。我们举例来说明具体的使用方法。\n\n我们将`my-first-module`复制一份，并修改名字为`my-second-module`，并将`my-second-module`中的`helloWorld`页面中的内容改为：\n\n```vue\n\x3c!-- modules/my-second-module/view/helloWorld.vue --\x3e\n\n<template>\n  <div class=\"absolute-center text-h3\">\n    hello from second module\n  </div>\n</template>\n\n<script>\nimport { defineComponent } from 'vue';\n\nexport default defineComponent({\n  name: 'SecondHelloWorldPage',\n})\n<\/script>\n\n```\n\n并将`my-second-module`里的`routers`中路由路径改为`/second`：\n\n\n```javascript\n// modules/my-second-module/routers/index.js\n\nexport default [\n  {\n    path: '/second',\n    component: () => import('../view/helloWorld.vue'),\n  }\n];\n\n```\n\n这时，我们通过浏览器可以分别访问`http://localhost:8080`和`http://localhost:8080/#/second`要以分别看到`my-first-module`和`my-second-module`中的两个页面。\n\n但是，我们很可能不希望两个页面的路由路径是这样的，而是需要遵从我们一套更复杂系统的整体规划。比如，我们需要使用`/hello/first`和`/hello/second`两个路径来访问这两个页面。我们新建一个模块，叫`wrapper`，目录结构如下：\n\n```\n--- app\n  -- src\n    -- modules\n      -- wrapper\n        -- index.js\n```\n\n其中：\n\n```javascript\n// modules/wrapper/index.js\n\nexport default {\n  config: {\n    dependencies: [\n      'core-modules',\n      'my-first-module',\n      'my-second-module',\n    ],\n  },\n  routers: [\n    {\n      ref: 'my-first-module>firstHello',\n      path: '/hello/first',\n    },\n    {\n      ref: 'my-second-module>secondHello',\n      path: '/hello/second',\n    },\n  ],\n}\n\n```\n\n这里我们通过`wrapper`中的`routers`定义，应用了其他模块的路由，方法是使用形如`ref: [模块名称]>[路由名称]`的定义，引用路由后相当于将被引用模块的相应路由配置复制到了这里，但我们可以通过重新定义像`path`这样的属性来覆盖被引用模块中的值。\n\n注意这里，我们添加了`dependencies`列表，让FreeEIS知道，这个`wrapper`模块依赖于此三个模块，以使他们可以在`wrapper`模块前被加载。\n\n此时会到浏览器，将会看到报错，因为根据路由名称从两个被引用模块中找不到`firstHello`和`secondHello`路由。我们回到两个被引用模块的路由定义中，将其修改为如下形式，添加`name`定义:\n\n```javascript\n// modules/my-first-module/routers/index.js\n\nexport default [\n  {\n    path: '/',\n    name: 'firstHello',\n    component: () => import('../view/helloWorld.vue'),\n  }\n];\n\n```\n\n```javascript\n// modules/my-second-module/routers/index.js\n\nexport default [\n  {\n    path: '/second',\n    name: 'secondHello',\n    component: () => import('../view/helloWorld.vue'),\n  }\n];\n\n```\n\n并且，修改`config.development.js`中启用的模块，如下：\n\n```javascript\n// config/config.development.js\n\nexport default {\n  modules: [\n    'wrapper',\n  ],\n\n  'my-first-module': {\n    greetingTo: '中国'\n  },\n};\n\n```\n\n这里我们告诉FreeEIS只加载`wrapper`一个模块，因为我们希望系统并不是直接加载引入进来的所有模块，而是更可控地对他们进行选择性地加载。这样做的好处是，当我们有些模块中的某些路由不需要暴露的时候，我们可以不在`wrapper`的路由定义中引用，而我们告诉FreeEIS只加载`wrapper`模块，这样系统就会只根据`wrapper`中的配置进行加载。\n\n比如，我们在`my-second-module`中添加一个新的页面：\n\n\n```javascript\n// modules/my-second-module/routers/index.js\n\nexport default [\n  {\n    path: '/second',\n    name: 'secondHello',\n    component: () => import('../view/helloWorld.vue'),\n  },\n  {\n    path: '/third',\n    name: 'thirdHello',\n    component: () => import('../view/helloWorld.vue'),\n  },\n];\n\n```\n\n如果我们直接将`my-second-module`加入到`config.development.js`的`modules`列表中，则我们可以通过访问`/third`来访问新定义的页面，但我们只添加`wrapper`到`config.development.js`的`modules`中后，我们不能访问这个页面，因为他不在`wrapper`的路由定义中。\n\n另外，需要注意的是，我们为了引用其他模块的路由，需要在被引用路由中添加`name`属性，以区分不同路由定义，这应该成为一种默认的良好习惯，因为模块开发人员所开发的模块就是要给系统集成人员或其他开发人员使用的。\n\n\n",h="## 内置模块介绍\n\n```文档更新中………```\n",f=(0,o.iH)(1),p={c:`${d}${u}${c}${m}${h}`,preComponents:()=>{console.log(l.Z);const e=[1,2,3,4,5,6,7,8,9,10].map((e=>(0,r.h)(i.Z,{name:e,style:"height: 200px"},(()=>[(0,r.h)("div",{class:"row no-wrap items-center justify-center"},[l.Z.width<630?null:(0,r.h)(a.Z,{opacity:.6,height:"110px",width:"160px",src:`/images/${e-1||10}.png`}),(0,r.h)(a.Z,{class:"q-mx-md",height:"140px",width:"190px",src:`/images/${e}.png`}),l.Z.width<630?null:(0,r.h)(a.Z,{opacity:.6,height:"110px",width:"160px",src:`/images/${e+1>10?1:e+1}.png`})])]))));return[(0,r.h)("h1",{class:"text-center q-mb-xl"},["FreeEIS 前端开发"]),(0,r.h)("div",{class:"row full-width items-center justify-center"},[(0,r.h)(s.Z,{class:"q-mt-md",height:"200px",style:"background: unset;max-width: 542px","transition-prev":"slide-right","transition-next":"slide-left",animated:!0,infinite:!0,swipeable:!0,autoplay:3500,modelValue:f.value,"onUpdate:model-value":e=>{f.value=e}},(()=>e))])]}}},40019:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>i});var o=t(72784),r=t(64037),s=t(99301);const i={fe:o["default"],be:r["default"],intro:s["default"]}},99301:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>r});const o='<p align="center">\n  <img\n    src="https://user-images.githubusercontent.com/33030594/227073920-03ed137f-c4f7-4ed7-ae05-d781dd1991f7.png"\n    alt="FreeEIS"\n    width="250"\n  />\n</p>\n\n\nFreeEIS，是一种可扩展的、企业级系统统一开发框架。FreeEIS旨在解决越来越流行的远程协作开发中，系统拆分及组装的问题。并且通过积累越来越多的功能模块，使得系统的搭建更快捷。\n\n## 背景\n```\n - 远程协作已经成为明显的趋势，特别是在软件开发领域。在疫情的影响下，此趋势更是越来越显著。很多人主动或被动在家办公，与团队进行远程协作。\n - 自由职业者是另一个趋势，越来越多的人会倾向于自由地选择短期的工作内容，而不是长期地被『绑』在一个组织内。\n - 很多企业，特别是中小软件企业面临着技术团队管理困难的问题。一方面远程办公给团队的沟通增加了成本，另一方面不同类型团队成员（本地、远程、兼职等）的协作给项目的拆分带来了困难。\n```\n\n## 目标\n\n我们期望能达到如下目标：\n - 任何有基础技术背景的人，都可以迅速搭建起一套可以运行的web系统，然后将目光集中在特定领域的新功能设计上！！\n - 『强迫』开发人员构建可通用的功能模块，以提高复用降低后续成本。\n - 完整的前后端支持，可全栈，可分离。\n - 方便地将一个大的项目切分成多个独立的模块，分配给任何类型的团队成员，开发人员不需要考虑系统的其他部分。\n - 每个模块都有足够的灵活性和可扩展性，即可是自成一体的庞大系统，也可以是小巧的复用组件或只是一个简单的工具方法。\n - 模块之间完全独立。\n - 模块之间通过简单的配置（或不需要配置）即可一起工作。\n - 通过实现基础的功能模块，使得一般的项目只需要考虑特定领域的业务逻辑。\n - 通过一定的规范，任何人开发的功能模块都可以被直接引用。\n - 扩展特定领域的功能模块，简化行业解决方案的实现。\n\n## 结构\n\nFreeEIS相信：任何功能模块都可以是通用的，只是通用范围的不同。如果开发中不考虑通用性，做多少个项目成本都一样高，如果考虑通用性，开发成本将随着积累的模块数量的增加而下降。（复用，在开发人员的脑袋里本是一个很普通的概念，但现实中，却不易做好。我们允许一个模块做不好，但要让不好的模块非常容易被替换或修改。）\n\nFreeEIS定位为：一个基座 + 一组通用模块 + 一组定制模块 = 一套系统。\n\n - 一个基座，指内核模块和项目脚手架。\n - 一组通用模块，指的是多数系统中都需要考虑的功能，如字典管理、日志管理、菜单管理、系统配置管理、错误代码管理、账号管理、组织机构管理、角色管理、权限控制等等。FreeEIS会逐步实现这些通用功能模块，并在可能情况下扩大范围。\n - 一组定制模块，指的是特定业务需求中，『非通用』的功能模块，需要开发团队根据客户需求定制开发。但在这些模块的开发中，依然可以考虑将它们实现成『相对』通用的模块，以备其他业务或其他人使用。\n\n 显然，通用模块数量越大，需要定制的模块越少，开发成本越低。\n\n## 特性\n\n\n- 🛠 高扩展性\n\n  “一切”皆可为模块，从一个漂亮的按钮、一个简单的运算工具函数，到一套完备的ERP系统，都可以做为FreeEIS中的模块。模块拆分灵活，模块间可零耦合，模块即插即用。同时考虑模块自身的扩展性，可开发模块做为另一模块的“插件”。\n\n- 🎯 聚焦业务逻辑\n\n  FreeEIS内核将与业务逻辑无关的功能预制，使得开发人员只需要考虑模块内部的业务逻辑，诸如模块加载、引用依赖、多语言支持、多样式支持、数据模型生成、权限管理与控制、路由生成、Mock功能等等都已经内置在FreeEIS内核中，模块开发过程中不需要再做考虑。特别是像数据模型生成、权限管理与控制，这类通常会消耗开发者大量精力的部分，也被剥离解耦，大大提高了开发效率。\n\n- 🚀 快速集成\n\n  FreeEIS中所有的功能都被拆分成大大小小的模块，在需要整合成为一整套系统的时候，只需要配置所需要的模块，或将模块代码（目录）放到统一的位置，FreeEIS内核将自动加载所有需要的模块，并整合为一套完整的系统。这使得系统级的组装更加灵活，可以根据需要极速集成成为大小和功能完全不同的完整系统。\n\n- 🍹 不改变开发习惯\n\n  FreeEIS尽力做到少封装，无SDK，避免改变现有的开发习惯。一个脚手架工程 + 一套简单的规范就可以实现快速的系统开发。\n\n\n- 🚪 代码安全\n\n  在某些场景下，我们不希望所有的开发人员拿到很多甚至所有功能模块的代码才可以运行调试自己的功能模块。FreeEIS的设计使得开发人员只关注自己所开发的模块也只需要访问到自己开发的功能模块的代码库，可以在不影响开发的情况下确保代码安全。\n\n\n## 使用\n\n### 前提条件\n\n当前版本中，前端使用了如下技术或框架，您需要已经对这些技术或框架有所了解甚至拥有相关经验：\n - [VUE3](https://vuejs.org/)是我们整个前端部分的基础。\n - [Quasar Framework](https://quasar.dev/)是一个基于VUE的框架，具有多种特性，如拥有丰富的组件，支持Material Design，支持跨平台等等。但FreeEIS中并禁止使用其他组件库，您依然可以根据自己的喜好选择，我们只是借助了Quasar Framework的脚手架和跨平台支持，甚至您也可以将FreeEIS放在与Quasar Framework无关的其他VUE工程中使用。\n\n当前版本中，后端使用了如下技术或框架，您需要已经对这些技术或框架有所了解甚至拥有相关经验：\n - [NodeJS](https://nodejs.org/)是基础！\n - [ExpressJS](http://expressjs.com/)是基础之上的基础😉。\n - [MongoDB](https://www.mongodb.com/)、[Mongoose](http://www.mongoosejs.net/), 目前已经实现的数据库操作模块基于Mongoose，但我们期望后续逐步添加更多数据库的支持。\n - [Redis](https://redis.io/)，建议使用Redis的docker镜像部署。\n\n### 前端\n\n```sh\n# 安装前端脚手架\n$ git clone https://github.com/freeeis/free-fe-starter-kit.git fe\n# 安装依赖包\n$ cd fe\n$ yarn install\n# 运行\n$ yarn start\n```\n\n\n### 后端\n\n在使用后端前，请先安装MongoDB和Redis，也可以使用远程部署的实例，FreeEIS的相关内置模块允许配置其地址和端口。另外，Redis不是必须的，如果无法连接到Redis，FreeEIS将使用[memory-cache](https://github.com/ptarjan/node-cache#readme)做为缓存，这不会影响开发或运行。\n\n```sh\n# 安装后端脚手架\n$ git clone https://github.com/freeeis/free-be-starter-kit.git be\n# 安装依赖包\n$ cd be\n$ yarn install\n# 创建存放机密数据的文件（也可手动创建）\n$ touch global.js\n# 运行\n$ yarn start\n```\n\n### 访问系统\n\n成功运行前后端工程后，通过链接[http://localhost:8080](http://localhost:8080/)来访问系统。也可通过修改配置，使前端运行后自动从浏览器中打开页面。\n\n## 内置功能模块\n\n我们期望通过提供一些内置的功能模块，来简化开发人员的工作，比如账号管理、权限控制这些在任何系统中都需要的功能，我们做成了模块，可以直接被引用。下面是一个列表，列出来目前我们所提供的内置功能模块，以及他们的功能。当然，根据我们的宗旨，我们不强制您使用任何一个内置模块，您可以根据自己的需要定制开发所有需要的模块，而只是使用FreeEIS的规范并用她来组装系统。并且我们鼓励您这么做，因为我们相信，在任何一个领域都有很多比我们更加专业的开发人员，我们希望有更多的人开发出越来越多的强大的功能模块供他人使用。\n\n| 模块      | 前端模块 | 后端模块 | 功能 | 说明|\n| :------- |------- |------- | ----|----: |\n| 内核 | [free-fe-core](https://github.com/freeeis/free-fe-core) | [free-be-core](https://github.com/freeeis/free-be-core) | 加载其他模块|默认在脚手架中|\n| 基础功能 | [free-fe-core-modules](https://github.com/freeeis/free-fe-core-modules) | [free-be-core-modules](https://github.com/freeeis/free-be-core-modules)| 数据字典、日志、菜单管理、<br>系统配置、错误代码管理、<br>缓存管理、哀悼日、文件处理、<br>数据校验方法、多语言支持、<br>多皮肤支持等等 | 默认在脚手架中|\n| 账号管理 | [free-fe-account](https://github.com/freeeis/free-fe-account) | [free-be-account](https://github.com/freeeis/free-be-account) |账号管理、组织结构管理、权限管理、<br>角色管理、权限控制| 默认在脚手架中|\n| 数据库 | / | [free-be-mongodb](https://github.com/freeeis/free-be-mongodb) |数据库操作| 默认在脚手架中|\n| 演示模块 | [free-fe-demo](https://github.com/freeeis/free-fe-demo) | [free-be-demo](https://github.com/freeeis/free-be-demo) |演示模块内部结构和使用方法| 默认在脚手架中|\n\n\n## 联系我们\n\n扫码添加微信加入交流群\n\n<img width="120" alt="" style="margin-left:24px" src="https://user-images.githubusercontent.com/33030594/227093642-b38b7871-16eb-48b6-b96a-191433dc55c2.png">\n\n\n## 贡献\n\nFreeEIS虽然已经在多个大型项目中得到了验证，但做为开源项目她依然处于比较早期的阶段，需要各位大牛的帮助一起成长。我们欢迎任何建议或意见或贡献，小到一个字的修改，大到架构的调整建议。我们感谢您的任何捐赠、PR、[Issue](https://github.com/freeeis/community/issues)等等，有任何相关问题都可以发邮件给我们：【[freeeis@xixineis.com](mailto:freeeis@xixineis.com)】。感谢🙏🙏！！\n',r=o},66432:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>o});const o={slogan:"Build your enterprise information system freely!",websiteTitle:"FreeEIS - Build enterprise information system freely",Home:"Home",Locale:"Locale",Introduction:"Introduction",FE:"Frontend",BE:"Backend",Integration:"Integration",Contribute1:"Caught a mistake or want to contribute to the documentation? Please go ",Contribute2:" to tell us. Thanks! "}},41070:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>o});const o={slogan:"自由地构建您的企业级数字化系统！",websiteTitle:"FreeEIS - 自由构建企业级数字化系统",Home:"首页",Locale:"语言",Introduction:"介绍",FE:"前端",BE:"后端",Integration:"系统集成",Contribute1:"发现了错误或者想要为文档做贡献？ 请到 ",Contribute2:" 告诉我们。非常感谢！ "}},87616:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>o});const o={config:{dependencies:["core-modules","themes"]},routers:[{path:"/",component:()=>Promise.all([t.e(736),t.e(429)]).then(t.bind(t,91429)),children:[{path:"",components:{page:()=>Promise.resolve().then(t.bind(t,46214))}},{path:"intro",components:{page:()=>Promise.all([t.e(736),t.e(555)]).then(t.bind(t,53555))},props:{page:{target:"intro"}}},{path:"fe",components:{page:()=>Promise.all([t.e(736),t.e(555)]).then(t.bind(t,53555))}},{path:"be",components:{page:()=>Promise.all([t.e(736),t.e(555)]).then(t.bind(t,53555))},props:{page:{target:"be"}}},{path:"integration",components:{page:()=>Promise.all([t.e(736),t.e(555)]).then(t.bind(t,53555))},props:{page:{target:"integration"}}}]}]}},46214:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>s});var o=t(59835),r=t(27712);const s=(0,o.aZ)({name:"FreeWebsite",setup(){const e=(0,r.QT)();return()=>(0,o.h)("div",{class:"absolute-center q-pb-xl"},[(0,o.h)("p",{align:"center"},(0,o.h)("img",{src:"https://user-images.githubusercontent.com/33030594/227073920-03ed137f-c4f7-4ed7-ae05-d781dd1991f7.png",alt:"FreeEIS",width:"250"})),(0,o.h)("div",{class:"text-center text-h2 text-grey"},"Free EIS"),(0,o.h)("div",{class:"text-center text-h6 text-grey-5 q-mt-md"},e.t("slogan"))])}})},84239:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>o});const o={EISThemeDefault:"Dark Mode",EISThemeDefault2:"Light Mode"}},21999:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>o});const o={EISThemeDefault:"暗模式",EISThemeDefault2:"亮模式"}},3521:(e,n,t)=>{"use strict";t.r(n),t.d(n,{default:()=>p});var o=t(59835);function r(e,n,t,r,s,i){return(0,o.kq)("",!0)}var s=t(9114),i=t(57674);const a=(0,o.aZ)({name:"themeDefault1",setup(){(0,o.wF)((()=>{(0,i.Z)("primary","#41a1e4"),s.Z.set(!1)}))}});var l=t(11639);const d=(0,l.Z)(a,[["render",r]]),u=d;function c(e,n,t,r,s,i){return(0,o.kq)("",!0)}const m=(0,o.aZ)({name:"themeDefault2",setup(){(0,o.wF)((()=>{s.Z.set(!1)}))}}),h=(0,l.Z)(m,[["render",c]]),f=h,p={IsTheme:!0,components:{EISThemeDefault:u,EISThemeDefault2:f}}},36278:(e,n,t)=>{"use strict";t.d(n,{Z:()=>l});var o=t(3746);const r=()=>({crumbs:[],canI:[],locale:localStorage.getItem("locale"),theme:localStorage.getItem("theme")||""}),s={};t(69665);const i={clearLoginStatus(){this.SET_CRUMBS(),this.CLEAR_CANI(),this.SET_THEME(),this.SET_LOCALE()},SET_CRUMBS(e){this.crumbs=e||""},ADD_CANI(e){this.canI&&this.canI.findIndex((n=>n.url===e.url))<0&&this.canI.push({url:e.url,can:e.can})},CLEAR_CANI(){this.canI=[]},SET_THEME(e){this.theme=e||"",localStorage.setItem("theme",e||"")},SET_LOCALE(e){this.locale=e||"",localStorage.setItem("locale",e||"")}},a=(0,o.Q_)("app",{getters:s,actions:i,state:r}),l=a},45002:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=45002,e.exports=n},12796:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=12796,e.exports=n},54262:(e,n,t)=>{var o={"./free-fe-core-modules/i18n/en-us/index.js":26343,"./free-fe-core-modules/i18n/zh-cn/index.js":86175};function r(e){var n=s(e);return t(n)}function s(e){if(!t.o(o,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return o[e]}r.keys=function(){return Object.keys(o)},r.resolve=s,e.exports=r,r.id=54262},11841:(e,n,t)=>{var o={"./free-fe-core-modules/index.js":48577,"./free-fe-core/index.js":21463};function r(e){var n=s(e);return t(n)}function s(e){if(!t.o(o,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return o[e]}r.keys=function(){return Object.keys(o)},r.resolve=s,e.exports=r,r.id=11841},42020:(e,n,t)=>{var o={"./config.default.js":28953,"./config.development.js":83938,"./config.production.js":17237,"./config.test.js":66630};function r(e){var n=s(e);return t(n)}function s(e){if(!t.o(o,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return o[e]}r.keys=function(){return Object.keys(o)},r.resolve=s,e.exports=r,r.id=42020},51093:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=51093,e.exports=n},45821:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=45821,e.exports=n},90082:(e,n,t)=>{var o={"./free/i18n/en-us/index.js":66432,"./free/i18n/zh-cn/index.js":41070,"./themes/i18n/en-us/index.js":84239,"./themes/i18n/zh-cn/index.js":21999};function r(e){var n=s(e);return t(n)}function s(e){if(!t.o(o,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return o[e]}r.keys=function(){return Object.keys(o)},r.resolve=s,e.exports=r,r.id=90082},57826:(e,n,t)=>{var o={"./free/docs/en-us/be/index.js":62488,"./free/docs/en-us/fe/index.js":90824,"./free/docs/en-us/index.js":56395,"./free/docs/en-us/intro/index.js":7629,"./free/docs/index.js":56682,"./free/docs/zh-cn/be/index.js":64037,"./free/docs/zh-cn/fe/index.js":72784,"./free/docs/zh-cn/index.js":40019,"./free/docs/zh-cn/intro/index.js":99301,"./free/i18n/en-us/index.js":66432,"./free/i18n/zh-cn/index.js":41070,"./free/index.js":87616,"./free/view/index.js":46214,"./themes/i18n/en-us/index.js":84239,"./themes/i18n/zh-cn/index.js":21999,"./themes/index.js":3521};function r(e){var n=s(e);return t(n)}function s(e){if(!t.o(o,e)){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}return o[e]}r.keys=function(){return Object.keys(o)},r.resolve=s,e.exports=r,r.id=57826},53373:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=53373,e.exports=n},59857:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=59857,e.exports=n},45433:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=45433,e.exports=n},71168:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=71168,e.exports=n}},n={};function t(o){var r=n[o];if(void 0!==r)return r.exports;var s=n[o]={exports:{}};return e[o].call(s.exports,s,s.exports,t),s.exports}t.m=e,(()=>{var e=[];t.O=(n,o,r,s)=>{if(!o){var i=1/0;for(u=0;u<e.length;u++){for(var[o,r,s]=e[u],a=!0,l=0;l<o.length;l++)(!1&s||i>=s)&&Object.keys(t.O).every((e=>t.O[e](o[l])))?o.splice(l--,1):(a=!1,s<i&&(i=s));if(a){e.splice(u--,1);var d=r();void 0!==d&&(n=d)}}return n}s=s||0;for(var u=e.length;u>0&&e[u-1][2]>s;u--)e[u]=e[u-1];e[u]=[o,r,s]}})(),(()=>{t.n=e=>{var n=e&&e.__esModule?()=>e["default"]:()=>e;return t.d(n,{a:n}),n}})(),(()=>{t.d=(e,n)=>{for(var o in n)t.o(n,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:n[o]})}})(),(()=>{t.f={},t.e=e=>Promise.all(Object.keys(t.f).reduce(((n,o)=>(t.f[o](e,n),n)),[]))})(),(()=>{t.u=e=>"js/"+e+"."+{429:"7210d0d8",456:"5a83de35",555:"40c46e13",739:"0dcbbf02"}[e]+".js"})(),(()=>{t.miniCssF=e=>"css/"+e+"."+{429:"a9be0b99",555:"f1bcccea"}[e]+".css"})(),(()=>{t.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}()})(),(()=>{t.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n)})(),(()=>{var e={},n="free_web_site:";t.l=(o,r,s,i)=>{if(e[o])e[o].push(r);else{var a,l;if(void 0!==s)for(var d=document.getElementsByTagName("script"),u=0;u<d.length;u++){var c=d[u];if(c.getAttribute("src")==o||c.getAttribute("data-webpack")==n+s){a=c;break}}a||(l=!0,a=document.createElement("script"),a.charset="utf-8",a.timeout=120,t.nc&&a.setAttribute("nonce",t.nc),a.setAttribute("data-webpack",n+s),a.src=o),e[o]=[r];var m=(n,t)=>{a.onerror=a.onload=null,clearTimeout(h);var r=e[o];if(delete e[o],a.parentNode&&a.parentNode.removeChild(a),r&&r.forEach((e=>e(t))),n)return n(t)},h=setTimeout(m.bind(null,void 0,{type:"timeout",target:a}),12e4);a.onerror=m.bind(null,a.onerror),a.onload=m.bind(null,a.onload),l&&document.head.appendChild(a)}}})(),(()=>{t.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}})(),(()=>{t.p=""})(),(()=>{if("undefined"!==typeof document){var e=(e,n,t,o,r)=>{var s=document.createElement("link");s.rel="stylesheet",s.type="text/css";var i=t=>{if(s.onerror=s.onload=null,"load"===t.type)o();else{var i=t&&("load"===t.type?"missing":t.type),a=t&&t.target&&t.target.href||n,l=new Error("Loading CSS chunk "+e+" failed.\n("+a+")");l.code="CSS_CHUNK_LOAD_FAILED",l.type=i,l.request=a,s.parentNode.removeChild(s),r(l)}};return s.onerror=s.onload=i,s.href=n,t?t.parentNode.insertBefore(s,t.nextSibling):document.head.appendChild(s),s},n=(e,n)=>{for(var t=document.getElementsByTagName("link"),o=0;o<t.length;o++){var r=t[o],s=r.getAttribute("data-href")||r.getAttribute("href");if("stylesheet"===r.rel&&(s===e||s===n))return r}var i=document.getElementsByTagName("style");for(o=0;o<i.length;o++){r=i[o],s=r.getAttribute("data-href");if(s===e||s===n)return r}},o=o=>new Promise(((r,s)=>{var i=t.miniCssF(o),a=t.p+i;if(n(i,a))return r();e(o,a,null,r,s)})),r={143:0};t.f.miniCss=(e,n)=>{var t={429:1,555:1};r[e]?n.push(r[e]):0!==r[e]&&t[e]&&n.push(r[e]=o(e).then((()=>{r[e]=0}),(n=>{throw delete r[e],n})))}}})(),(()=>{var e={143:0};t.f.j=(n,o)=>{var r=t.o(e,n)?e[n]:void 0;if(0!==r)if(r)o.push(r[2]);else{var s=new Promise(((t,o)=>r=e[n]=[t,o]));o.push(r[2]=s);var i=t.p+t.u(n),a=new Error,l=o=>{if(t.o(e,n)&&(r=e[n],0!==r&&(e[n]=void 0),r)){var s=o&&("load"===o.type?"missing":o.type),i=o&&o.target&&o.target.src;a.message="Loading chunk "+n+" failed.\n("+s+": "+i+")",a.name="ChunkLoadError",a.type=s,a.request=i,r[1](a)}};t.l(i,l,"chunk-"+n,n)}},t.O.j=n=>0===e[n];var n=(n,o)=>{var r,s,[i,a,l]=o,d=0;if(i.some((n=>0!==e[n]))){for(r in a)t.o(a,r)&&(t.m[r]=a[r]);if(l)var u=l(t)}for(n&&n(o);d<i.length;d++)s=i[d],t.o(e,s)&&e[s]&&e[s][0](),e[s]=0;return t.O(u)},o=globalThis["webpackChunkfree_web_site"]=globalThis["webpackChunkfree_web_site"]||[];o.forEach(n.bind(null,0)),o.push=n.bind(null,o.push.bind(o))})();var o=t.O(void 0,[736],(()=>t(93450)));o=t.O(o)})();